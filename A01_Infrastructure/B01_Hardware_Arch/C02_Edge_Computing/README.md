# C02 Edge Computing

**æ‰€å±å­é¢†åŸŸ**: [B01_Hardware_Arch](../README.md)  
**åˆ›å»ºæ—¥æœŸ**: 2026-01-30  
**æœ€åæ›´æ–°**: 2026-01-30

## ğŸ“‹ ä¸»é¢˜å®šä½

è¾¹ç¼˜è®¡ç®—ï¼ˆEdge Computingï¼‰æ˜¯ä¸€ç§å°†è®¡ç®—ã€å­˜å‚¨å’Œç½‘ç»œèµ„æºéƒ¨ç½²åœ¨é è¿‘æ•°æ®æºæˆ–ç”¨æˆ·çš„ç½‘ç»œè¾¹ç¼˜çš„åˆ†å¸ƒå¼è®¡ç®—èŒƒå¼ã€‚å®ƒé€šè¿‡åœ¨æ•°æ®äº§ç”Ÿçš„æºå¤´é™„è¿‘å¤„ç†æ•°æ®ï¼Œæ˜¾è‘—é™ä½å»¶è¿Ÿã€å‡å°‘å¸¦å®½æ¶ˆè€—ã€å¢å¼ºéšç§ä¿æŠ¤ï¼Œå¹¶æ”¯æŒå®æ—¶å†³ç­–ã€‚

éšç€5Gã€ç‰©è”ç½‘ï¼ˆIoTï¼‰ã€äººå·¥æ™ºèƒ½å’Œè‡ªåŠ¨é©¾é©¶ç­‰æŠ€æœ¯çš„å‘å±•ï¼Œè¾¹ç¼˜è®¡ç®—å·²æˆä¸ºè¿æ¥äº‘ä¸­å¿ƒä¸ç»ˆç«¯è®¾å¤‡çš„å…³é”®æŠ€æœ¯å±‚ã€‚ä»æ™ºèƒ½å·¥å‚çš„è½¦é—´ç½‘å…³åˆ°è‡ªåŠ¨é©¾é©¶æ±½è½¦çš„ onboard è®¡ç®—å•å…ƒï¼Œä»æ™ºæ…§åŸå¸‚çš„è¾¹ç¼˜èŠ‚ç‚¹åˆ°é›¶å”®å•†åº—çš„AIæ‘„åƒå¤´ï¼Œè¾¹ç¼˜è®¡ç®—æ­£åœ¨é‡å¡‘è®¡ç®—åŸºç¡€è®¾æ–½çš„æ‹“æ‰‘ç»“æ„ã€‚

æœ¬ä¸“é¢˜ç³»ç»Ÿæ¢è®¨è¾¹ç¼˜è®¡ç®—çš„æ¶æ„è®¾è®¡ã€å…³é”®æŠ€æœ¯ã€éƒ¨ç½²å®è·µä»¥åŠå…¸å‹åº”ç”¨åœºæ™¯ï¼Œä¸ºæ„å»ºé«˜æ•ˆã€å¯é ã€å®‰å…¨çš„è¾¹ç¼˜è®¡ç®—åŸºç¡€è®¾æ–½æä¾›å…¨é¢æŒ‡å¯¼ã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### åŸºæœ¬å®šä¹‰

**è¾¹ç¼˜è®¡ç®—ï¼ˆEdge Computingï¼‰**: åœ¨é è¿‘æ•°æ®æºæˆ–ç”¨æˆ·çš„ç½‘ç»œè¾¹ç¼˜ä¾§ï¼Œèåˆç½‘ç»œã€è®¡ç®—ã€å­˜å‚¨ã€åº”ç”¨æ ¸å¿ƒèƒ½åŠ›çš„åˆ†å¸ƒå¼å¼€æ”¾å¹³å°ï¼Œå°±è¿‘æä¾›è¾¹ç¼˜æ™ºèƒ½æœåŠ¡ã€‚

**è¾¹ç¼˜èŠ‚ç‚¹ï¼ˆEdge Nodeï¼‰**: éƒ¨ç½²åœ¨ç½‘ç»œè¾¹ç¼˜çš„è®¡ç®—è®¾å¤‡ï¼Œå¯ä»¥æ˜¯ç½‘å…³ã€æœåŠ¡å™¨ã€å·¥ä¸šPCæˆ–åµŒå…¥å¼è®¾å¤‡ï¼Œè´Ÿè´£æœ¬åœ°æ•°æ®å¤„ç†ã€‚

**å¤šæ¥å…¥è¾¹ç¼˜è®¡ç®—ï¼ˆMEC, Multi-access Edge Computingï¼‰**: 3GPPå’ŒETSIæ ‡å‡†åŒ–çš„è¾¹ç¼˜è®¡ç®—æ¶æ„ï¼Œéƒ¨ç½²åœ¨ç§»åŠ¨é€šä¿¡ç½‘ç»œè¾¹ç¼˜ï¼Œä¸ºç§»åŠ¨ç”¨æˆ·æä¾›ä½å»¶è¿ŸæœåŠ¡ã€‚

**é›¾è®¡ç®—ï¼ˆFog Computingï¼‰**: ç”±Ciscoæå‡ºçš„æ¦‚å¿µï¼Œå¼ºè°ƒäº‘åˆ°è®¾å¤‡ä¹‹é—´çš„å¤šå±‚æ¬¡è®¡ç®—ï¼Œæ˜¯è¾¹ç¼˜è®¡ç®—çš„æ‰©å±•æ¦‚å¿µã€‚

### è¾¹ç¼˜è®¡ç®—æ¶æ„å±‚æ¬¡

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         è¾¹ç¼˜è®¡ç®—æ¶æ„å…¨æ™¯                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                     â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚                     äº‘å±‚ (Cloud Layer)                       â”‚   â”‚
â”‚   â”‚  â€¢ å¤§è§„æ¨¡æ•°æ®ä¸­å¿ƒ / å…¬æœ‰äº‘ / ç§æœ‰äº‘                           â”‚   â”‚
â”‚   â”‚  â€¢ é•¿æœŸæ•°æ®å­˜å‚¨ / å…¨å±€AIæ¨¡å‹è®­ç»ƒ / é›†ä¸­ç®¡ç†                    â”‚   â”‚
â”‚   â”‚  â€¢ é«˜å»¶è¿Ÿå®¹å¿ / é«˜ååé‡ / å¼¹æ€§è®¡ç®—                           â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                              â†‘â†“ (WAN)                               â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚                   åŒºåŸŸå±‚ (Regional Layer)                    â”‚   â”‚
â”‚   â”‚  â€¢ åŒºåŸŸæ•°æ®ä¸­å¿ƒ / CDNèŠ‚ç‚¹ / 5Gæ ¸å¿ƒç½‘                         â”‚   â”‚
â”‚   â”‚  â€¢ åŒºåŸŸå†…å®¹åˆ†å‘ / ä¸­é—´æ•°æ®èšåˆ / åŒºåŸŸAIæ¨ç†                   â”‚   â”‚
â”‚   â”‚  â€¢ ä¸­ç­‰å»¶è¿Ÿ / åŒºåŸŸè¦†ç›– / æ•°æ®æ±‡èš                            â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                              â†‘â†“ (Metro)                             â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚                    è¾¹ç¼˜å±‚ (Edge Layer)                       â”‚   â”‚
â”‚   â”‚  â€¢ MECæœåŠ¡å™¨ / è¾¹ç¼˜ç½‘å…³ / æœ¬åœ°æ•°æ®ä¸­å¿ƒ                        â”‚   â”‚
â”‚   â”‚  â€¢ å®æ—¶æ•°æ®å¤„ç† / æœ¬åœ°AIæ¨ç† / è®¾å¤‡ç®¡ç†                       â”‚   â”‚
â”‚   â”‚  â€¢ ä½å»¶è¿Ÿ (<20ms) / æœ¬åœ°åŒ–è®¡ç®— / éšç§ä¿æŠ¤                     â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                              â†‘â†“ (LAN/5G)                            â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚                   ç°åœºå±‚ (Far Edge/On-site)                  â”‚   â”‚
â”‚   â”‚  â€¢ å·¥ä¸šç½‘å…³ / æ™ºèƒ½æ‘„åƒå¤´ / åµŒå…¥å¼è®¾å¤‡ / è½¦è½½è®¡ç®—               â”‚   â”‚
â”‚   â”‚  â€¢ æ¯«ç§’çº§å“åº” / åè®®è½¬æ¢ / æœ¬åœ°è‡ªæ²»                           â”‚   â”‚
â”‚   â”‚  â€¢ è¶…ä½å»¶è¿Ÿ (<5ms) / ç¡¬å®æ—¶ / ç¦»çº¿è¿è¡Œ                        â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                              â†‘â†“ (Field Bus/WiFi/BLE)                â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚                   è®¾å¤‡å±‚ (Device Layer)                      â”‚   â”‚
â”‚   â”‚  â€¢ ä¼ æ„Ÿå™¨ / æ‰§è¡Œå™¨ / æ™ºèƒ½ç»ˆç«¯ / å¯ç©¿æˆ´è®¾å¤‡                    â”‚   â”‚
â”‚   â”‚  â€¢ æ•°æ®é‡‡é›† / ç®€å•é¢„å¤„ç† / è¾¹ç¼˜ååŒ                          â”‚   â”‚
â”‚   â”‚  â€¢ èµ„æºå—é™ / ç”µæ± ä¾›ç”µ / å¤šæ ·åè®®                            â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### è¾¹ç¼˜è®¡ç®—ä¸äº‘è®¡ç®—çš„å¯¹æ¯”

| ç‰¹æ€§ | äº‘è®¡ç®— (Cloud) | è¾¹ç¼˜è®¡ç®— (Edge) | é›¾è®¡ç®— (Fog) |
|-----|---------------|----------------|-------------|
| **å»¶è¿Ÿ** | 50-200ms | 1-20ms | 5-50ms |
| **å¸¦å®½éœ€æ±‚** | é«˜ï¼ˆå…¨é‡æ•°æ®ä¸Šä¼ ï¼‰ | ä½ï¼ˆæœ¬åœ°å¤„ç†ï¼Œç­›é€‰ä¸Šä¼ ï¼‰ | ä¸­ |
| **è®¡ç®—èƒ½åŠ›** | å‡ ä¹æ— é™ | æœ‰é™ä½†è¶³å¤Ÿ | ä¸­ç­‰ |
| **æ•°æ®ä½ç½®** | é›†ä¸­æ•°æ®ä¸­å¿ƒ | æ•°æ®æºé™„è¿‘ | å¤šå±‚æ¬¡åˆ†å¸ƒ |
| **éšç§å®‰å…¨** | ä¾èµ–ä¼ è¾“åŠ å¯† | æœ¬åœ°å¤„ç†ï¼Œæ•°æ®ä¸å‡ºåœº | åˆ†å±‚å®‰å…¨ |
| **è¿ç»´å¤æ‚åº¦** | ç»Ÿä¸€ç®¡ç† | åˆ†å¸ƒå¼ç®¡ç†æŒ‘æˆ˜ | ä¸­ç­‰ |
| **é€‚ç”¨åœºæ™¯** | æ‰¹å¤„ç†ã€å¤§æ•°æ®åˆ†æ | å®æ—¶å“åº”ã€æœ¬åœ°è‡ªæ²» | æ··åˆåœºæ™¯ |

### è¾¹ç¼˜è®¡ç®—å…³é”®æŠ€æœ¯

**1. è¾¹ç¼˜è®¡ç®—ç¡¬ä»¶å½¢æ€**

| å½¢æ€ | ç‰¹ç‚¹ | å…¸å‹åº”ç”¨ |
|-----|------|---------|
| **è¾¹ç¼˜æœåŠ¡å™¨** | æ ‡å‡†æœºæ¶å¼ï¼Œæ€§èƒ½å¼ºå¤§ | åŒºåŸŸæ•°æ®ä¸­å¿ƒï¼ŒMEC |
| **å·¥ä¸šç½‘å…³** | å·¥ä¸šçº§å¯é æ€§ï¼Œå¤šåè®®æ”¯æŒ | æ™ºèƒ½åˆ¶é€ ï¼Œå·¥ä¸š4.0 |
| **åµŒå…¥å¼è®¾å¤‡** | ä½åŠŸè€—ï¼Œç´§å‡‘è®¾è®¡ | æ™ºèƒ½æ‘„åƒå¤´ï¼Œæ— äººæœº |
| **è½¦è½½è®¡ç®—å•å…ƒ** | è½¦è§„çº§ï¼Œé«˜å¯é æ€§ | è‡ªåŠ¨é©¾é©¶ï¼Œæ™ºèƒ½åº§èˆ± |
| **æ™ºèƒ½NIC/DPU** | ç½‘ç»œå¸è½½ï¼Œç¡¬ä»¶åŠ é€Ÿ | é«˜æ€§èƒ½è¾¹ç¼˜ç½‘å…³ |
| **è¾¹ç¼˜AIèŠ¯ç‰‡** | ä½åŠŸè€—AIæ¨ç† | æ™ºèƒ½IoTè®¾å¤‡ |

**2. è¾¹ç¼˜AIä¸æ¨¡å‹ä¼˜åŒ–**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     è¾¹ç¼˜AIæ¨¡å‹ä¼˜åŒ–æŠ€æœ¯æ ˆ                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                â”‚
â”‚  æ¨¡å‹å‹ç¼©                                                      â”‚
â”‚  â”œâ”€â”€ é‡åŒ– (Quantization)                                       â”‚
â”‚  â”‚   â”œâ”€â”€ INT8 é‡åŒ– - å‡å°‘4xå†…å­˜ï¼ŒåŠ é€Ÿ2-4x                      â”‚
â”‚  â”‚   â”œâ”€â”€ INT4/äºŒå€¼åŒ– - æç«¯å‹ç¼©                                â”‚
â”‚  â”‚   â””â”€â”€ æ··åˆç²¾åº¦ - ç²¾åº¦ä¸æ•ˆç‡å¹³è¡¡                             â”‚
â”‚  â”œâ”€â”€ å‰ªæ (Pruning)                                            â”‚
â”‚  â”‚   â”œâ”€â”€ ç»“æ„åŒ–å‰ªæ - ç§»é™¤æ•´ä¸ªé€šé“                             â”‚
â”‚  â”‚   â””â”€â”€ éç»“æ„åŒ–å‰ªæ - ç¨€ç–åŒ–æƒé‡                             â”‚
â”‚  â””â”€â”€ çŸ¥è¯†è’¸é¦ (Knowledge Distillation)                         â”‚
â”‚      â””â”€â”€ å¤§æ¨¡å‹ â†’ å°æ¨¡å‹è¿ç§»çŸ¥è¯†                               â”‚
â”‚                                                                â”‚
â”‚  ç¼–è¯‘ä¼˜åŒ–                                                      â”‚
â”‚  â”œâ”€â”€ TensorRT (NVIDIA)                                         â”‚
â”‚  â”œâ”€â”€ ONNX Runtime                                              â”‚
â”‚  â”œâ”€â”€ OpenVINO (Intel)                                          â”‚
â”‚  â”œâ”€â”€ TFLite (Google)                                           â”‚
â”‚  â””â”€â”€ MNN/NCNN (ç§»åŠ¨ç«¯ä¼˜åŒ–)                                     â”‚
â”‚                                                                â”‚
â”‚  ç¡¬ä»¶åŠ é€Ÿ                                                      â”‚
â”‚  â”œâ”€â”€ GPU (CUDA/OpenCL)                                         â”‚
â”‚  â”œâ”€â”€ NPU/TPU (ä¸“ç”¨AIèŠ¯ç‰‡)                                      â”‚
â”‚  â”œâ”€â”€ FPGA (å¯ç¼–ç¨‹åŠ é€Ÿ)                                         â”‚
â”‚  â””â”€â”€ DSP (æ•°å­—ä¿¡å·å¤„ç†)                                        â”‚
â”‚                                                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**3. è¾¹ç¼˜ç¼–æ’ä¸å®¹å™¨åŒ–**

```yaml
# è¾¹ç¼˜å®¹å™¨ç¼–æ’ç‰¹ç‚¹
è¾¹ç¼˜å®¹å™¨åŒ–:
  æŒ‘æˆ˜:
    - èµ„æºå—é™: CPU/å†…å­˜/å­˜å‚¨æœ‰é™
    - ç½‘ç»œä¸ç¨³å®š: é—´æ­‡æ€§è¿æ¥
    - å¼‚æ„ç¡¬ä»¶: ARM/x86/GPUç­‰å¤šæ ·æ¶æ„
    - å®‰å…¨è¾¹ç•Œ: ç‰©ç†å¯æ¥è§¦æ€§é£é™©
    
  è§£å†³æ–¹æ¡ˆ:
    K3s:
      æè¿°: è½»é‡çº§Kuberneteså‘è¡Œç‰ˆ
      ç‰¹ç‚¹:
        - å•äºŒè¿›åˆ¶æ–‡ä»¶ (<100MB)
        - ä½å†…å­˜å ç”¨ (<512MBè¿è¡Œ)
        - å†…ç½®sqliteæ›¿ä»£etcd
        - æ”¯æŒARM/ARM64
        
    KubeEdge:
      æè¿°: KubernetesåŸç”Ÿè¾¹ç¼˜è®¡ç®—æ¡†æ¶
      ç‰¹ç‚¹:
        - äº‘è¾¹ååŒæ¶æ„
        - è¾¹ç¼˜è‡ªæ²»èƒ½åŠ›
        - è®¾å¤‡ç®¡ç†æ’ä»¶
        - è¾¹ç¼˜-äº‘åŒæ­¥
        
    OpenYurt:
      æè¿°: é˜¿é‡Œäº‘å¼€æºçš„è¾¹ç¼˜Kubernetes
      ç‰¹ç‚¹:
        - é›¶ä¾µå…¥æ‰©å±•
        - è¾¹ç¼˜å•å…ƒåŒ–
        - èŠ‚ç‚¹æ± æ²»ç†
        
    SuperEdge:
      æè¿°: è…¾è®¯äº‘å¼€æºè¾¹ç¼˜å®¹å™¨
      ç‰¹ç‚¹:
        - åˆ†å¸ƒå¼å¥åº·æ£€æŸ¥
        - è¾¹ç¼˜éš§é“ç½‘ç»œ
        - è¾¹ç¼˜ Ingress
```

### 5G MECæ¶æ„è¯¦è§£

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        5G MEC ç³»ç»Ÿæ¶æ„                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚                      5G Core Network                           â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚  â”‚
â”‚  â”‚  â”‚     AMF      â”‚  â”‚     SMF      â”‚  â”‚        UPF           â”‚â”‚  â”‚
â”‚  â”‚  â”‚ æ¥å…¥ç®¡ç†åŠŸèƒ½  â”‚  â”‚ ä¼šè¯ç®¡ç†åŠŸèƒ½  â”‚  â”‚ ç”¨æˆ·é¢åŠŸèƒ½           â”‚â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚  â”‚
â”‚  â”‚         â†‘                   â†‘                    â†‘            â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚            â”‚                   â”‚                    â”‚               â”‚
â”‚            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
â”‚                         N6æ¥å£ (æ•°æ®é¢)                              â”‚
â”‚                              â†“                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚                      MEC Platform                              â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚  â”‚
â”‚  â”‚  â”‚  MEPM        â”‚  â”‚  MEP         â”‚  â”‚  MEC Applications    â”‚â”‚  â”‚
â”‚  â”‚  â”‚ å¹³å°ç®¡ç†å™¨    â”‚  â”‚ å¹³å°å®ä½“      â”‚  â”‚  â”œâ”€AIæ¨ç†æœåŠ¡        â”‚â”‚  â”‚
â”‚  â”‚  â”‚              â”‚  â”‚              â”‚  â”‚  â”œâ”€è§†é¢‘åˆ†æ          â”‚â”‚  â”‚
â”‚  â”‚  â”‚              â”‚  â”‚  â”œâ”€æœåŠ¡æ³¨å†Œ   â”‚  â”‚  â”œâ”€IoTç½‘å…³           â”‚â”‚  â”‚
â”‚  â”‚  â”‚              â”‚  â”‚  â”œâ”€æµé‡è§„åˆ™   â”‚  â”‚  â”œâ”€CDNç¼“å­˜           â”‚â”‚  â”‚
â”‚  â”‚  â”‚              â”‚  â”‚  â””â”€DNSç®¡ç†    â”‚  â”‚  â””â”€æ¸¸æˆæœåŠ¡å™¨        â”‚â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚  â”‚
â”‚  â”‚                                                                â”‚  â”‚
â”‚  â”‚  èƒ½åŠ›å¼€æ”¾: Location API â”‚ QoS API â”‚ Bandwidth Mgmt â”‚ AF API   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                              â†“                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚                    RAN (æ— çº¿æ¥å…¥ç½‘)                             â”‚  â”‚
â”‚  â”‚         gNB (5GåŸºç«™) â”€â”€â”€â”€â”€â”€â”€â”€ UE (ç”¨æˆ·è®¾å¤‡)                    â”‚  â”‚
â”‚  â”‚                                                                â”‚  â”‚
â”‚  â”‚  MECéƒ¨ç½²é€‰é¡¹:                                                  â”‚  â”‚
â”‚  â”‚  â€¢ é€‰é¡¹1: å…±å€éƒ¨ç½² (MEPä¸gNBåŒæœºæˆ¿)                             â”‚  â”‚
â”‚  â”‚  â€¢ é€‰é¡¹2: è¾¹ç¼˜DC (æ¥å…¥æ±‡èšç‚¹)                                   â”‚  â”‚
â”‚  â”‚  â€¢ é€‰é¡¹3: åŒºåŸŸDC (å¤šä¸ªåŸºç«™æ±‡èš)                                 â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ› ï¸ æŠ€æœ¯å®è·µ

### è¾¹ç¼˜è®¾å¤‡é€‰å‹ä¸é…ç½®

**1. è¾¹ç¼˜è®¾å¤‡æ€§èƒ½å¯¹æ¯”**

| è®¾å¤‡ | CPU | GPU/NPU | å†…å­˜ | åŠŸè€— | é€‚ç”¨åœºæ™¯ |
|-----|-----|---------|------|------|---------|
| **NVIDIA Jetson Nano** | Quad-core ARM | 128-core Maxwell | 4GB | 5-10W | å…¥é—¨çº§AI |
| **NVIDIA Jetson Orin** | 12-core ARM | 2048-core Ampere | 32GB | 15-60W | é«˜çº§è¾¹ç¼˜AI |
| **Intel NUC** | x86 Core i5/i7 | Intel Iris Xe | 32GB+ | 65W | é€šç”¨è¾¹ç¼˜æœåŠ¡å™¨ |
| **Raspberry Pi 5** | Quad-core ARM | VideoCore VII | 8GB | 5-8W | è½»é‡çº§ç½‘å…³ |
| **Coral Dev Board** | Quad-core ARM | Edge TPU | 1GB | 3W | ä¸“ç”¨æ¨ç† |
| **AWS Panorama** | Intel Atom | NVIDIA Jetson | 8GB | 25W | å·¥ä¸šè§†è§‰ |

**2. è¾¹ç¼˜ç½‘å…³é…ç½®è„šæœ¬**

```bash
#!/bin/bash
# è¾¹ç¼˜ç½‘å…³åˆå§‹åŒ–é…ç½®è„šæœ¬
# é€‚ç”¨äºå·¥ä¸šè¾¹ç¼˜ç½‘å…³è®¾å¤‡

set -e

# é…ç½®å‚æ•°
EDGE_NODE_ID="edge-$(cat /sys/class/net/eth0/address | tr -d ':')"
EDGE_LOCATION="factory-floor-1"
CLOUD_ENDPOINT="mqtt.cloud-platform.example.com"

# 1. ç³»ç»ŸåŸºç¡€é…ç½®
setup_edge_system() {
    echo "=== é…ç½®è¾¹ç¼˜èŠ‚ç‚¹åŸºç¡€ ==="
    
    # è®¾ç½®ä¸»æœºå
    hostnamectl set-hostname "$EDGE_NODE_ID"
    
    # é…ç½®æ—¶åŒº
    timedatectl set-timezone Asia/Shanghai
    
    # å¯ç”¨ç¡¬ä»¶çœ‹é—¨ç‹—
    modprobe softdog
    echo 'softdog' >> /etc/modules
    
    # é…ç½®æ—¥å¿—é™åˆ¶ï¼ˆè¾¹ç¼˜å­˜å‚¨æœ‰é™ï¼‰
    cat > /etc/systemd/journald.conf << 'EOF'
[Journal]
SystemMaxUse=500M
SystemMaxFileSize=50M
MaxFileSec=7day
EOF
    systemctl restart systemd-journald
}

# 2. ç½‘ç»œä¼˜åŒ–ï¼ˆè¾¹ç¼˜ç½‘ç»œä¸ç¨³å®šï¼‰
configure_edge_network() {
    echo "=== é…ç½®è¾¹ç¼˜ç½‘ç»œä¼˜åŒ– ==="
    
    cat > /etc/sysctl.d/99-edge-network.conf << 'EOF'
# è¾¹ç¼˜ç½‘ç»œä¼˜åŒ–
net.ipv4.tcp_keepalive_time = 60
net.ipv4.tcp_keepalive_intvl = 10
net.ipv4.tcp_keepalive_probes = 6

# å¿«é€Ÿå›æ”¶å¤±æ•ˆè¿æ¥
net.ipv4.tcp_tw_reuse = 1
net.ipv4.tcp_fin_timeout = 10

# æ›´å¤§çš„ç¼“å†²åŒºï¼ˆåº”å¯¹é—´æ­‡æ€§é«˜å¸¦å®½ï¼‰
net.core.rmem_max = 16777216
net.core.wmem_max = 16777216
net.ipv4.tcp_rmem = 4096 87380 16777216
net.ipv4.tcp_wmem = 4096 65536 16777216

# MQTTä¼˜åŒ–
net.ipv4.tcp_notsent_lowat = 16384
EOF
    
    sysctl --system
    
    # é…ç½®åŒç½‘å¡ï¼ˆä¸Šè¡Œ/ä¸‹è¡Œåˆ†ç¦»ï¼‰
    cat > /etc/netplan/01-edge-network.yaml << EOF
network:
  version: 2
  ethernets:
    eth0:
      dhcp4: true
      dhcp4-overrides:
        route-metric: 100
      nameservers:
        addresses: [8.8.8.8, 114.114.114.114]
    eth1:
      addresses:
        - 192.168.100.1/24
      nameservers:
        addresses: [192.168.100.1]
EOF
    netplan apply
}

# 3. å®‰è£…è¾¹ç¼˜è¿è¡Œæ—¶
install_edge_runtime() {
    echo "=== å®‰è£…è¾¹ç¼˜è¿è¡Œæ—¶ ==="
    
    # å®‰è£…Docker
    curl -fsSL https://get.docker.com | sh
    systemctl enable docker
    systemctl start docker
    
    # å®‰è£…K3s (è½»é‡çº§Kubernetes)
    curl -sfL https://get.k3s.io | INSTALL_K3S_EXEC="server --disable traefik --write-kubeconfig-mode 644" sh -
    
    # å®‰è£…MQTT Broker (æœ¬åœ°æ¶ˆæ¯æ€»çº¿)
    docker run -d \
        --name mosquitto \
        --restart always \
        -p 1883:1883 \
        -p 9001:9001 \
        -v /opt/mosquitto:/mosquitto \
        eclipse-mosquitto
    
    # å®‰è£…Node-RED (æµå¼å¤„ç†)
    docker run -d \
        --name nodered \
        --restart always \
        -p 1880:1880 \
        -v /opt/nodered:/data \
        nodered/node-red
}

# 4. é…ç½®è¾¹ç¼˜AIè¿è¡Œæ—¶ï¼ˆNVIDIAè®¾å¤‡ï¼‰
setup_edge_ai() {
    echo "=== é…ç½®è¾¹ç¼˜AIç¯å¢ƒ ==="
    
    # å®‰è£…JetPack (Jetsonè®¾å¤‡)
    if [ -f /etc/nv_tegra_release ]; then
        # å®‰è£…TensorRT
        apt-get update
        apt-get install -y tensorrt python3-libnvinfer-dev
        
        # å®‰è£…PyTorch (ARMç‰ˆæœ¬)
        pip3 install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cpu
        
        # é…ç½®Jetsonæ—¶é’Ÿå’ŒåŠŸè€—æ¨¡å¼
        jetson_clocks
        nvpmodel -m 0  # æœ€å¤§åŠŸç‡æ¨¡å¼
    fi
    
    # å®‰è£…Edge TPU Runtime (Coralè®¾å¤‡)
    if [ -d /sys/bus/usb/devices ]; then
        echo "deb https://packages.cloud.google.com/apt coral-edgetpu-stable main" | tee /etc/apt/sources.list.d/coral-edgetpu.list
        curl https://packages.cloud.google.com/apt/doc/apt-key.gpg | apt-key add -
        apt-get update
        apt-get install -y libedgetpu1-std python3-pycoral
    fi
}

# 5. é…ç½®è¾¹ç¼˜æ•°æ®é‡‡é›†
setup_data_collection() {
    echo "=== é…ç½®æ•°æ®é‡‡é›† ==="
    
    # å®‰è£…Telegraf
    curl -s https://repos.influxdata.com/influxdata-archive_compat.key | apt-key add -
    echo "deb https://repos.influxdata.com/debian stable main" | tee /etc/apt/sources.list.d/influxdb.list
    apt-get update && apt-get install -y telegraf
    
    # é…ç½®Telegraf
    cat > /etc/telegraf/telegraf.conf << EOF
[agent]
  interval = "10s"
  flush_interval = "10s"

[[inputs.cpu]]
[[inputs.mem]]
[[inputs.disk]]
[[inputs.diskio]]
[[inputs.net]]
[[inputs.temp]]

[[outputs.mqtt]]
  servers = ["$CLOUD_ENDPOINT:1883"]
  topic_prefix = "edge/$EDGE_NODE_ID/metrics"
  data_format = "json"
EOF
    
    systemctl enable telegraf
    systemctl start telegraf
}

# 6. é…ç½®ç¦»çº¿è‡ªæ²»èƒ½åŠ›
setup_offline_autonomy() {
    echo "=== é…ç½®ç¦»çº¿è‡ªæ²»èƒ½åŠ› ==="
    
    # æœ¬åœ°è§„åˆ™å¼•æ“
    mkdir -p /opt/edge-rules
    cat > /opt/edge-rules/local-controller.py << 'PYTHON'
#!/usr/bin/env python3
"""è¾¹ç¼˜æœ¬åœ°è‡ªæ²»æ§åˆ¶å™¨"""

import json
import paho.mqtt.client as mqtt
from datetime import datetime

class LocalController:
    def __init__(self):
        self.rules = []
        self.cloud_connected = False
        
    def load_rules(self):
        """åŠ è½½æœ¬åœ°è§„åˆ™"""
        try:
            with open('/opt/edge-rules/rules.json') as f:
                self.rules = json.load(f)
        except:
            self.rules = []
    
    def evaluate_rules(self, sensor_data):
        """è¯„ä¼°è§„åˆ™å¹¶æ‰§è¡ŒåŠ¨ä½œ"""
        for rule in self.rules:
            if self._check_condition(rule['condition'], sensor_data):
                self._execute_action(rule['action'])
    
    def _check_condition(self, condition, data):
        """æ£€æŸ¥æ¡ä»¶æ˜¯å¦æ»¡è¶³"""
        sensor = condition.get('sensor')
        threshold = condition.get('threshold')
        operator = condition.get('operator', '>')
        
        value = data.get(sensor)
        if value is None:
            return False
        
        if operator == '>':
            return value > threshold
        elif operator == '<':
            return value < threshold
        return False
    
    def _execute_action(self, action):
        """æ‰§è¡ŒåŠ¨ä½œ"""
        print(f"[LOCAL] æ‰§è¡ŒåŠ¨ä½œ: {action}")
        # æ§åˆ¶æœ¬åœ°æ‰§è¡Œå™¨
        # è®°å½•æœ¬åœ°äº‹ä»¶
        with open('/opt/edge-rules/events.log', 'a') as f:
            f.write(f"{datetime.now()}: {json.dumps(action)}\n")

if __name__ == '__main__':
    controller = LocalController()
    controller.load_rules()
    print("æœ¬åœ°è‡ªæ²»æ§åˆ¶å™¨å·²å¯åŠ¨")
PYTHON
    
    chmod +x /opt/edge-rules/local-controller.py
    
    # åˆ›å»ºsystemdæœåŠ¡
    cat > /etc/systemd/system/edge-controller.service << 'EOF'
[Unit]
Description=Edge Local Controller
After=network.target

[Service]
Type=simple
ExecStart=/usr/bin/python3 /opt/edge-rules/local-controller.py
Restart=always

[Install]
WantedBy=multi-user.target
EOF
    
    systemctl daemon-reload
    systemctl enable edge-controller
}

# 7. å®‰å…¨åŠ å›º
harden_edge_security() {
    echo "=== è¾¹ç¼˜å®‰å…¨åŠ å›º ==="
    
    # é…ç½®é˜²ç«å¢™ï¼ˆä»…å…è®¸å¿…è¦ç«¯å£ï¼‰
    ufw default deny incoming
    ufw default allow outgoing
    ufw allow 22/tcp      # SSH
    ufw allow 1883/tcp    # MQTT
    ufw allow 6443/tcp    # K3s API
    ufw allow from 192.168.100.0/24  # æœ¬åœ°è®¾å¤‡ç½‘æ®µ
    ufw --force enable
    
    # é…ç½®fail2ban
    apt-get install -y fail2ban
    
    # ç¦ç”¨root SSHç™»å½•
    sed -i 's/#PermitRootLogin yes/PermitRootLogin no/' /etc/ssh/sshd_config
    systemctl restart sshd
    
    # é…ç½®è‡ªåŠ¨å®‰å…¨æ›´æ–°
    apt-get install -y unattended-upgrades
}

# ä¸»æ‰§è¡Œæµç¨‹
main() {
    setup_edge_system
    configure_edge_network
    install_edge_runtime
    setup_edge_ai
    setup_data_collection
    setup_offline_autonomy
    harden_edge_security
    
    echo "=== è¾¹ç¼˜ç½‘å…³é…ç½®å®Œæˆ ==="
    echo "èŠ‚ç‚¹ID: $EDGE_NODE_ID"
    echo "è¯·æ£€æŸ¥å„é¡¹æœåŠ¡çŠ¶æ€"
}

main "$@"
```

### è¾¹ç¼˜AIåº”ç”¨å¼€å‘

**1. è¾¹ç¼˜AIæ¨ç†æœåŠ¡ï¼ˆPython + TFLiteï¼‰**

```python
#!/usr/bin/env python3
"""
è¾¹ç¼˜AIæ¨ç†æœåŠ¡
æ”¯æŒæ¨¡å‹çƒ­æ›´æ–°ã€æ‰¹é‡æ¨ç†ã€æœ¬åœ°ç¼“å­˜
"""

import os
import time
import json
import logging
from pathlib import Path
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass
from datetime import datetime
import threading
import queue

import numpy as np

# æ¡ä»¶å¯¼å…¥æ¨ç†å¼•æ“
try:
    import tflite_runtime.interpreter as tflite
    TFLITE_AVAILABLE = True
except ImportError:
    TFLITE_AVAILABLE = False

try:
    import tensorrt as trt
    import pycuda.driver as cuda
    import pycuda.autoinit
    TRT_AVAILABLE = True
except ImportError:
    TRT_AVAILABLE = False


@dataclass
class InferenceResult:
    """æ¨ç†ç»“æœ"""
    model_name: str
    prediction: np.ndarray
    confidence: float
    inference_time_ms: float
    timestamp: datetime
    metadata: Dict


class EdgeInferenceEngine:
    """è¾¹ç¼˜æ¨ç†å¼•æ“"""
    
    def __init__(self, model_dir: str = "/opt/edge-models"):
        self.model_dir = Path(model_dir)
        self.model_dir.mkdir(exist_ok=True)
        
        self.models: Dict[str, any] = {}
        self.model_info: Dict[str, Dict] = {}
        self.batch_queue: queue.Queue = queue.Queue(maxsize=100)
        self.is_running = False
        
        self.logger = logging.getLogger(__name__)
        
        # æ€§èƒ½ç»Ÿè®¡
        self.stats = {
            'total_inferences': 0,
            'total_latency_ms': 0,
            'errors': 0
        }
    
    def load_model(self, model_name: str, model_type: str = "tflite") -> bool:
        """åŠ è½½æ¨¡å‹"""
        model_path = self.model_dir / f"{model_name}.{model_type}"
        
        if not model_path.exists():
            self.logger.error(f"æ¨¡å‹æ–‡ä»¶ä¸å­˜åœ¨: {model_path}")
            return False
        
        try:
            if model_type == "tflite" and TFLITE_AVAILABLE:
                interpreter = tflite.Interpreter(model_path=str(model_path))
                interpreter.allocate_tensors()
                
                self.models[model_name] = interpreter
                self.model_info[model_name] = {
                    'type': 'tflite',
                    'input_details': interpreter.get_input_details(),
                    'output_details': interpreter.get_output_details(),
                    'loaded_at': datetime.now()
                }
                
            elif model_type == "trt" and TRT_AVAILABLE:
                # TensorRTæ¨¡å‹åŠ è½½
                logger = trt.Logger(trt.Logger.WARNING)
                runtime = trt.Runtime(logger)
                
                with open(model_path, 'rb') as f:
                    engine = runtime.deserialize_cuda_engine(f.read())
                
                self.models[model_name] = engine
                self.model_info[model_name] = {
                    'type': 'tensorrt',
                    'loaded_at': datetime.now()
                }
            
            self.logger.info(f"æ¨¡å‹åŠ è½½æˆåŠŸ: {model_name}")
            return True
            
        except Exception as e:
            self.logger.error(f"æ¨¡å‹åŠ è½½å¤±è´¥: {e}")
            return False
    
    def infer(self, 
              model_name: str, 
              input_data: np.ndarray,
              batch_size: int = 1) -> Optional[InferenceResult]:
        """æ‰§è¡Œæ¨ç†"""
        start_time = time.time()
        
        try:
            model = self.models.get(model_name)
            if model is None:
                raise ValueError(f"æ¨¡å‹æœªåŠ è½½: {model_name}")
            
            model_type = self.model_info[model_name]['type']
            
            if model_type == 'tflite':
                result = self._infer_tflite(model, input_data)
            elif model_type == 'tensorrt':
                result = self._infer_tensorrt(model, input_data)
            else:
                raise ValueError(f"ä¸æ”¯æŒçš„æ¨¡å‹ç±»å‹: {model_type}")
            
            inference_time = (time.time() - start_time) * 1000
            
            # æ›´æ–°ç»Ÿè®¡
            self.stats['total_inferences'] += 1
            self.stats['total_latency_ms'] += inference_time
            
            return InferenceResult(
                model_name=model_name,
                prediction=result['prediction'],
                confidence=result.get('confidence', 0.0),
                inference_time_ms=inference_time,
                timestamp=datetime.now(),
                metadata={
                    'model_type': model_type,
                    'batch_size': batch_size,
                    'input_shape': input_data.shape
                }
            )
            
        except Exception as e:
            self.stats['errors'] += 1
            self.logger.error(f"æ¨ç†å¤±è´¥: {e}")
            return None
    
    def _infer_tflite(self, interpreter, input_data: np.ndarray) -> Dict:
        """TFLiteæ¨ç†"""
        input_details = interpreter.get_input_details()
        output_details = interpreter.get_output_details()
        
        # å‡†å¤‡è¾“å…¥
        input_shape = input_details[0]['shape']
        if input_data.shape != tuple(input_shape):
            input_data = np.resize(input_data, input_shape)
        
        # è®¾ç½®è¾“å…¥
        interpreter.set_tensor(input_details[0]['index'], input_data.astype(np.float32))
        
        # æ‰§è¡Œæ¨ç†
        interpreter.invoke()
        
        # è·å–è¾“å‡º
        output = interpreter.get_tensor(output_details[0]['index'])
        
        return {
            'prediction': output,
            'confidence': float(np.max(output))
        }
    
    def _infer_tensorrt(self, engine, input_data: np.ndarray) -> Dict:
        """TensorRTæ¨ç†"""
        context = engine.create_execution_context()
        
        # åˆ†é…å†…å­˜
        d_input = cuda.mem_alloc(input_data.nbytes)
        output = np.empty(engine.get_binding_shape(1), dtype=np.float32)
        d_output = cuda.mem_alloc(output.nbytes)
        
        # æ•°æ®ä¼ è¾“
        cuda.memcpy_htod(d_input, input_data)
        
        # æ‰§è¡Œ
        context.execute_v2([int(d_input), int(d_output)])
        
        # è·å–ç»“æœ
        cuda.memcpy_dtoh(output, d_output)
        
        return {
            'prediction': output,
            'confidence': float(np.max(output))
        }
    
    def batch_infer(self, 
                    model_name: str,
                    requests: List[Dict]) -> List[InferenceResult]:
        """æ‰¹é‡æ¨ç†ï¼ˆæé«˜ååé‡ï¼‰"""
        results = []
        
        # æ‰¹é‡å‡†å¤‡æ•°æ®
        batch_data = np.stack([r['input'] for r in requests])
        
        # æ‰§è¡Œæ‰¹é‡æ¨ç†
        result = self.infer(model_name, batch_data, batch_size=len(requests))
        
        if result:
            # æ‹†åˆ†ç»“æœ
            for i, req in enumerate(requests):
                results.append(InferenceResult(
                    model_name=model_name,
                    prediction=result.prediction[i],
                    confidence=float(result.prediction[i].max()),
                    inference_time_ms=result.inference_time_ms / len(requests),
                    timestamp=result.timestamp,
                    metadata={**result.metadata, 'request_id': req.get('id')}
                ))
        
        return results
    
    def get_stats(self) -> Dict:
        """è·å–ç»Ÿè®¡ä¿¡æ¯"""
        total = self.stats['total_inferences']
        avg_latency = (self.stats['total_latency_ms'] / total 
                      if total > 0 else 0)
        
        return {
            'total_inferences': total,
            'average_latency_ms': round(avg_latency, 2),
            'error_rate': round(self.stats['errors'] / (total + 1e-10) * 100, 2),
            'loaded_models': list(self.models.keys()),
            'uptime_seconds': time.time() - getattr(self, '_start_time', time.time())
        }
    
    def start_batch_service(self, model_name: str, max_batch_size: int = 8):
        """å¯åŠ¨æ‰¹é‡æ¨ç†æœåŠ¡"""
        self.is_running = True
        self._start_time = time.time()
        
        def batch_processor():
            while self.is_running:
                batch = []
                timeout = 0.01  # 10msè¶…æ—¶
                
                # æ”¶é›†æ‰¹é‡è¯·æ±‚
                try:
                    while len(batch) < max_batch_size:
                        item = self.batch_queue.get(timeout=timeout)
                        batch.append(item)
                        timeout = 0.001  # åç»­è¯·æ±‚æ›´çŸ­çš„ç­‰å¾…
                except queue.Empty:
                    pass
                
                if batch:
                    results = self.batch_infer(model_name, batch)
                    # åˆ†å‘ç»“æœ
                    for i, result in enumerate(results):
                        if i < len(batch) and 'callback' in batch[i]:
                            batch[i]['callback'](result)
        
        thread = threading.Thread(target=batch_processor, daemon=True)
        thread.start()
        self.logger.info(f"æ‰¹é‡æ¨ç†æœåŠ¡å·²å¯åŠ¨: {model_name}")


# è¾¹ç¼˜AIåº”ç”¨ç¤ºä¾‹
class EdgeAIApplication:
    """è¾¹ç¼˜AIåº”ç”¨å°è£…"""
    
    def __init__(self):
        self.engine = EdgeInferenceEngine()
        
    def init_object_detection(self):
        """åˆå§‹åŒ–ç›®æ ‡æ£€æµ‹åº”ç”¨"""
        # åŠ è½½MobileNet SSDæ¨¡å‹
        self.engine.load_model("mobilenet_ssd", "tflite")
        self.engine.start_batch_service("mobilenet_ssd", max_batch_size=4)
        
    def init_anomaly_detection(self):
        """åˆå§‹åŒ–å¼‚å¸¸æ£€æµ‹åº”ç”¨"""
        # åŠ è½½è‡ªç¼–ç å™¨æ¨¡å‹
        self.engine.load_model("autoencoder", "tflite")
    
    def process_video_frame(self, frame: np.ndarray) -> Dict:
        """å¤„ç†è§†é¢‘å¸§"""
        # é¢„å¤„ç†
        input_data = self._preprocess_frame(frame)
        
        # æäº¤åˆ°æ‰¹é‡é˜Ÿåˆ—
        result_event = threading.Event()
        result_container = {}
        
        def callback(result):
            result_container['result'] = result
            result_event.set()
        
        self.engine.batch_queue.put({
            'input': input_data,
            'callback': callback
        })
        
        # ç­‰å¾…ç»“æœï¼ˆè®¾ç½®è¶…æ—¶ï¼‰
        if result_event.wait(timeout=5.0):
            return self._postprocess_detection(result_container['result'])
        else:
            return {'error': 'æ¨ç†è¶…æ—¶'}
    
    def _preprocess_frame(self, frame: np.ndarray) -> np.ndarray:
        """å¸§é¢„å¤„ç†"""
        # è°ƒæ•´å¤§å°ã€å½’ä¸€åŒ–ç­‰
        resized = np.resize(frame, (300, 300, 3))
        normalized = resized / 255.0
        return np.expand_dims(normalized, axis=0).astype(np.float32)
    
    def _postprocess_detection(self, result: InferenceResult) -> Dict:
        """æ£€æµ‹ç»“æœåå¤„ç†"""
        predictions = result.prediction
        
        detections = []
        # è§£ææ£€æµ‹æ¡†
        for i in range(predictions.shape[1]):
            confidence = predictions[0, i, 2]
            if confidence > 0.5:
                detections.append({
                    'class_id': int(predictions[0, i, 1]),
                    'confidence': float(confidence),
                    'bbox': predictions[0, i, 3:7].tolist()
                })
        
        return {
            'detections': detections,
            'inference_time_ms': result.inference_time_ms,
            'timestamp': result.timestamp.isoformat()
        }


if __name__ == '__main__':
    # æµ‹è¯•ä»£ç 
    logging.basicConfig(level=logging.INFO)
    
    app = EdgeAIApplication()
    app.init_object_detection()
    
    # æ¨¡æ‹Ÿæ¨ç†
    test_frame = np.random.rand(480, 640, 3) * 255
    result = app.process_video_frame(test_frame.astype(np.uint8))
    print(f"æ£€æµ‹ç»“æœ: {result}")
    
    # æ‰“å°ç»Ÿè®¡
    print(f"å¼•æ“ç»Ÿè®¡: {app.engine.get_stats()}")
```

**2. è¾¹ç¼˜-äº‘ååŒæ•°æ®åŒæ­¥**

```python
#!/usr/bin/env python3
"""
è¾¹ç¼˜-äº‘ååŒæ•°æ®åŒæ­¥æ¨¡å—
æ”¯æŒæ–­ç‚¹ç»­ä¼ ã€æ•°æ®å‹ç¼©ã€ä¼˜å…ˆçº§é˜Ÿåˆ—
"""

import json
import gzip
import queue
import threading
import time
from dataclasses import dataclass, asdict
from datetime import datetime
from enum import IntEnum
from pathlib import Path
import sqlite3
from typing import Optional

import paho.mqtt.client as mqtt


class Priority(IntEnum):
    """æ•°æ®ä¼˜å…ˆçº§"""
    CRITICAL = 0    # å‘Šè­¦ã€å¼‚å¸¸
    HIGH = 1        # é‡è¦ä¸šåŠ¡æ•°æ®
    NORMAL = 2      # å¸¸è§„æ•°æ®
    LOW = 3         # æ—¥å¿—ã€ç»Ÿè®¡


@dataclass
class DataPacket:
    """æ•°æ®åŒ…"""
    id: str
    timestamp: datetime
    priority: Priority
    data_type: str
    payload: bytes
    compressed: bool = False
    retry_count: int = 0
    
    def to_bytes(self) -> bytes:
        """åºåˆ—åŒ–"""
        data = {
            'id': self.id,
            'timestamp': self.timestamp.isoformat(),
            'priority': self.priority.value,
            'data_type': self.data_type,
            'payload': self.payload.decode('latin-1'),
            'compressed': self.compressed
        }
        return json.dumps(data).encode()
    
    @classmethod
    def from_bytes(cls, data: bytes) -> 'DataPacket':
        """ååºåˆ—åŒ–"""
        obj = json.loads(data)
        return cls(
            id=obj['id'],
            timestamp=datetime.fromisoformat(obj['timestamp']),
            priority=Priority(obj['priority']),
            data_type=obj['data_type'],
            payload=obj['payload'].encode('latin-1'),
            compressed=obj['compressed']
        )


class LocalStorage:
    """æœ¬åœ°æŒä¹…åŒ–å­˜å‚¨ï¼ˆSQLiteï¼‰"""
    
    def __init__(self, db_path: str = "/opt/edge-data/sync.db"):
        self.db_path = Path(db_path)
        self.db_path.parent.mkdir(parents=True, exist_ok=True)
        self._init_db()
    
    def _init_db(self):
        """åˆå§‹åŒ–æ•°æ®åº“"""
        with sqlite3.connect(self.db_path) as conn:
            conn.execute('''
                CREATE TABLE IF NOT EXISTS pending_packets (
                    id TEXT PRIMARY KEY,
                    timestamp TEXT,
                    priority INTEGER,
                    data_type TEXT,
                    payload BLOB,
                    compressed INTEGER,
                    retry_count INTEGER DEFAULT 0,
                    created_at TEXT DEFAULT CURRENT_TIMESTAMP
                )
            ''')
            conn.execute('''
                CREATE INDEX IF NOT EXISTS idx_priority 
                ON pending_packets(priority, timestamp)
            ''')
    
    def save(self, packet: DataPacket):
        """ä¿å­˜æ•°æ®åŒ…"""
        with sqlite3.connect(self.db_path) as conn:
            conn.execute('''
                INSERT OR REPLACE INTO pending_packets 
                (id, timestamp, priority, data_type, payload, compressed, retry_count)
                VALUES (?, ?, ?, ?, ?, ?, ?)
            ''', (
                packet.id,
                packet.timestamp.isoformat(),
                packet.priority.value,
                packet.data_type,
                packet.payload,
                int(packet.compressed),
                packet.retry_count
            ))
    
    def load_pending(self, limit: int = 100) -> list:
        """åŠ è½½å¾…å‘é€æ•°æ®"""
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.execute('''
                SELECT * FROM pending_packets 
                ORDER BY priority ASC, timestamp ASC 
                LIMIT ?
            ''', (limit,))
            
            packets = []
            for row in cursor:
                packets.append(DataPacket(
                    id=row[0],
                    timestamp=datetime.fromisoformat(row[1]),
                    priority=Priority(row[2]),
                    data_type=row[3],
                    payload=row[4],
                    compressed=bool(row[5]),
                    retry_count=row[6]
                ))
            return packets
    
    def delete(self, packet_id: str):
        """åˆ é™¤å·²å‘é€æ•°æ®"""
        with sqlite3.connect(self.db_path) as conn:
            conn.execute('DELETE FROM pending_packets WHERE id = ?', (packet_id,))
    
    def increment_retry(self, packet_id: str):
        """å¢åŠ é‡è¯•è®¡æ•°"""
        with sqlite3.connect(self.db_path) as conn:
            conn.execute('''
                UPDATE pending_packets 
                SET retry_count = retry_count + 1 
                WHERE id = ?
            ''', (packet_id,))
    
    def cleanup_old(self, days: int = 7):
        """æ¸…ç†è¿‡æœŸæ•°æ®"""
        with sqlite3.connect(self.db_path) as conn:
            conn.execute('''
                DELETE FROM pending_packets 
                WHERE created_at < datetime('now', '-{} days')
            '''.format(days))


class EdgeCloudSync:
    """è¾¹ç¼˜äº‘åŒæ­¥ç®¡ç†å™¨"""
    
    def __init__(self, 
                 cloud_endpoint: str,
                 device_id: str,
                 compress_threshold: int = 1024):
        self.cloud_endpoint = cloud_endpoint
        self.device_id = device_id
        self.compress_threshold = compress_threshold
        
        self.local_storage = LocalStorage()
        self.mqtt_client: Optional[mqtt.Client] = None
        self.is_connected = False
        
        # ä¼˜å…ˆçº§é˜Ÿåˆ—ï¼ˆå†…å­˜ä¸­ï¼‰
        self.mem_queue = queue.PriorityQueue(maxsize=10000)
        
        # ç»Ÿè®¡
        self.stats = {
            'sent': 0,
            'queued': 0,
            'failed': 0,
            'bytes_sent': 0
        }
        
        self._stop_event = threading.Event()
    
    def connect(self):
        """è¿æ¥äº‘å¹³å°"""
        self.mqtt_client = mqtt.Client(client_id=f"edge-{self.device_id}")
        
        def on_connect(client, userdata, flags, rc):
            if rc == 0:
                self.is_connected = True
                print(f"å·²è¿æ¥åˆ°äº‘å¹³å°: {self.cloud_endpoint}")
                # è®¢é˜…äº‘ç«¯å‘½ä»¤
                client.subscribe(f"cloud/{self.device_id}/cmd")
            else:
                print(f"è¿æ¥å¤±è´¥ï¼Œè¿”å›ç : {rc}")
        
        def on_disconnect(client, userdata, rc):
            self.is_connected = False
            print(f"ä¸äº‘å¹³å°æ–­å¼€è¿æ¥: {rc}")
        
        def on_message(client, userdata, msg):
            # å¤„ç†äº‘ç«¯å‘½ä»¤
            print(f"æ”¶åˆ°äº‘ç«¯å‘½ä»¤: {msg.topic} - {msg.payload}")
        
        self.mqtt_client.on_connect = on_connect
        self.mqtt_client.on_disconnect = on_disconnect
        self.mqtt_client.on_message = on_message
        
        # é…ç½®é‡è¿
        self.mqtt_client.reconnect_delay_set(min_delay=1, max_delay=60)
        
        # è¿æ¥ï¼ˆå¼‚æ­¥ï¼‰
        self.mqtt_client.connect_async(self.cloud_endpoint, 1883, keepalive=60)
        self.mqtt_client.loop_start()
    
    def publish(self, 
                data: dict,
                data_type: str = "telemetry",
                priority: Priority = Priority.NORMAL,
                compress: bool = True):
        """å‘å¸ƒæ•°æ®"""
        # åºåˆ—åŒ–
        payload = json.dumps(data).encode()
        original_size = len(payload)
        
        # å‹ç¼©ï¼ˆå¦‚æœå¯ç”¨ä¸”è¶…è¿‡é˜ˆå€¼ï¼‰
        is_compressed = False
        if compress and original_size > self.compress_threshold:
            payload = gzip.compress(payload)
            is_compressed = True
        
        packet = DataPacket(
            id=f"{self.device_id}-{int(time.time()*1000)}",
            timestamp=datetime.now(),
            priority=priority,
            data_type=data_type,
            payload=payload,
            compressed=is_compressed
        )
        
        # é«˜ä¼˜å…ˆçº§ç›´æ¥å°è¯•å‘é€
        if priority == Priority.CRITICAL and self.is_connected:
            if self._send_packet(packet):
                return
        
        # å¦åˆ™åŠ å…¥é˜Ÿåˆ—
        try:
            self.mem_queue.put((priority.value, packet), block=False)
            self.stats['queued'] += 1
        except queue.Full:
            # å†…å­˜é˜Ÿåˆ—æ»¡ï¼ŒæŒä¹…åŒ–åˆ°æœ¬åœ°å­˜å‚¨
            self.local_storage.save(packet)
    
    def _send_packet(self, packet: DataPacket) -> bool:
        """å‘é€å•ä¸ªæ•°æ®åŒ…"""
        if not self.is_connected or not self.mqtt_client:
            return False
        
        try:
            topic = f"edge/{self.device_id}/{packet.data_type}"
            payload = packet.to_bytes()
            
            # æ ¹æ®ä¼˜å…ˆçº§è®¾ç½®QoS
            qos = 0 if packet.priority == Priority.LOW else 1
            if packet.priority == Priority.CRITICAL:
                qos = 2
            
            result = self.mqtt_client.publish(topic, payload, qos=qos)
            
            if result.rc == mqtt.MQTT_ERR_SUCCESS:
                self.stats['sent'] += 1
                self.stats['bytes_sent'] += len(payload)
                return True
            else:
                return False
                
        except Exception as e:
            print(f"å‘é€å¤±è´¥: {e}")
            return False
    
    def start_sync_worker(self):
        """å¯åŠ¨åŒæ­¥å·¥ä½œçº¿ç¨‹"""
        def sync_loop():
            while not self._stop_event.is_set():
                if self.is_connected:
                    # 1. ä¼˜å…ˆå¤„ç†å†…å­˜é˜Ÿåˆ—
                    try:
                        _, packet = self.mem_queue.get(timeout=0.1)
                        if not self._send_packet(packet):
                            # å‘é€å¤±è´¥ï¼ŒæŒä¹…åŒ–åˆ°æœ¬åœ°
                            packet.retry_count += 1
                            self.local_storage.save(packet)
                            self.stats['failed'] += 1
                        continue
                    except queue.Empty:
                        pass
                    
                    # 2. å¤„ç†æœ¬åœ°å­˜å‚¨çš„ç§¯å‹æ•°æ®
                    pending = self.local_storage.load_pending(limit=10)
                    for packet in pending:
                        if self._send_packet(packet):
                            self.local_storage.delete(packet.id)
                        else:
                            self.local_storage.increment_retry(packet.id)
                            break  # è¿æ¥å¯èƒ½æœ‰é—®é¢˜ï¼Œç­‰å¾…ä¸‹æ¬¡å¾ªç¯
                
                time.sleep(0.1)
        
        thread = threading.Thread(target=sync_loop, daemon=True)
        thread.start()
        print("åŒæ­¥å·¥ä½œçº¿ç¨‹å·²å¯åŠ¨")
    
    def get_stats(self) -> dict:
        """è·å–ç»Ÿè®¡ä¿¡æ¯"""
        return {
            **self.stats,
            'is_connected': self.is_connected,
            'queue_size': self.mem_queue.qsize(),
            'storage_pending': len(self.local_storage.load_pending(limit=999999))
        }
    
    def stop(self):
        """åœæ­¢åŒæ­¥æœåŠ¡"""
        self._stop_event.set()
        if self.mqtt_client:
            self.mqtt_client.loop_stop()
            self.mqtt_client.disconnect()


# ä½¿ç”¨ç¤ºä¾‹
if __name__ == '__main__':
    sync = EdgeCloudSync(
        cloud_endpoint="mqtt.example.com",
        device_id="edge-001"
    )
    
    sync.connect()
    sync.start_sync_worker()
    
    # æ¨¡æ‹Ÿæ•°æ®ä¸ŠæŠ¥
    for i in range(100):
        sync.publish(
            data={
                'temperature': 25 + i % 10,
                'humidity': 60 + i % 20,
                'timestamp': datetime.now().isoformat()
            },
            data_type="sensors",
            priority=Priority.NORMAL
        )
        time.sleep(0.1)
    
    # å‘é€é«˜ä¼˜å…ˆçº§å‘Šè­¦
    sync.publish(
        data={'alert': 'temperature_critical', 'value': 85},
        data_type="alerts",
        priority=Priority.CRITICAL
    )
    
    print(f"åŒæ­¥ç»Ÿè®¡: {sync.get_stats()}")
    
    time.sleep(5)
    sync.stop()
```

## ğŸ“š èµ„æºç´¢å¼•

### è¾¹ç¼˜è®¡ç®—æ ‡å‡†ä¸è§„èŒƒ

| æ ‡å‡†ç»„ç»‡ | è§„èŒƒåç§° | è¯´æ˜ |
|---------|---------|------|
| **ETSI** | MECæ ‡å‡†ç³»åˆ— (GS MEC 003-011) | å¤šæ¥å…¥è¾¹ç¼˜è®¡ç®—æ¡†æ¶ |
| **3GPP** | TS 23.501/23.502 | 5Gç³»ç»Ÿæ¶æ„ä¸­çš„è¾¹ç¼˜è®¡ç®— |
| **IEC** | IEC 61499 | åˆ†å¸ƒå¼å·¥ä¸šè‡ªåŠ¨åŒ– |
| **IEEE** | IEEE 1934 | Fog Computingå‚è€ƒæ¶æ„ |
| **LF Edge** | Akraino/EdgeX Foundry | å¼€æºè¾¹ç¼˜è®¡ç®—æ¡†æ¶ |

### å¼€æºé¡¹ç›®ä¸å¹³å°

| é¡¹ç›® | ç±»å‹ | é“¾æ¥ | è¯´æ˜ |
|-----|------|------|------|
| **KubeEdge** | è¾¹ç¼˜ç¼–æ’ | [kubeedge.io](https://kubeedge.io) | KubernetesåŸç”Ÿè¾¹ç¼˜æ¡†æ¶ |
| **EdgeX Foundry** | IoTå¹³å° | [edgexfoundry.org](https://www.edgexfoundry.org) | é€šç”¨è¾¹ç¼˜IoTå¹³å° |
| **K3s** | è½»é‡çº§K8s | [k3s.io](https://k3s.io) | è¾¹ç¼˜Kuberneteså‘è¡Œç‰ˆ |
| **OpenYurt** | è¾¹ç¼˜å®¹å™¨ | [openyurt.io](https://openyurt.io) | é˜¿é‡Œäº‘å¼€æºè¾¹ç¼˜å®¹å™¨ |
| **Akraino** | è¾¹ç¼˜å †æ ˆ | [akraino.org](https://www.akraino.org) | LF Edgeè“å›¾é¡¹ç›® |
| **Eclipse ioFog** | è¾¹ç¼˜å¹³å° | [iofog.org](https://iofog.org) | Eclipseè¾¹ç¼˜è®¡ç®—å¹³å° |
| **Baidu Edge Computing** | å•†ä¸šå¹³å° | [bce.baidu.com](https://bce.baidu.com) | ç™¾åº¦æ™ºèƒ½äº‘è¾¹ç¼˜è®¡ç®— |
| **AWS IoT Greengrass** | å•†ä¸šå¹³å° | [aws.amazon.com/greengrass](https://aws.amazon.com/greengrass/) | AWSè¾¹ç¼˜è®¡ç®—æœåŠ¡ |
| **Azure IoT Edge** | å•†ä¸šå¹³å° | [azure.microsoft.com/iotedge](https://azure.microsoft.com/services/iot-edge/) | Azureè¾¹ç¼˜è®¡ç®— |

### è¾¹ç¼˜AIæ¡†æ¶ä¸å·¥å…·

| æ¡†æ¶ | å‚å•† | é€‚ç”¨å¹³å° | è¯´æ˜ |
|-----|------|---------|------|
| **TensorRT** | NVIDIA | Jetson, GPU | é«˜æ€§èƒ½æ¨ç†ä¼˜åŒ– |
| **OpenVINO** | Intel | x86, Movidius | Intelè®¾å¤‡ä¼˜åŒ– |
| **TFLite** | Google | ARM, MCU | ç§»åŠ¨ç«¯/åµŒå…¥å¼æ¨ç† |
| **ONNX Runtime** | Microsoft | è·¨å¹³å° | é€šç”¨æ¨ç†å¼•æ“ |
| **NCNN** | Tencent | ARM | ç§»åŠ¨ç«¯é«˜æ€§èƒ½ |
| **MNN** | Alibaba | è·¨å¹³å° | è½»é‡æ¨ç†å¼•æ“ |
| **Paddle Lite** | Baidu | ARM, FPGA | é£æ¡¨è½»é‡ç‰ˆ |

### è¾¹ç¼˜ç¡¬ä»¶å‚è€ƒè®¾è®¡

| å¹³å° | ç±»å‹ | æ€§èƒ½ | é€‚ç”¨åœºæ™¯ |
|-----|------|------|---------|
| **NVIDIA Jetson** | åµŒå…¥å¼AI | 0.5-275 TOPS | æœºå™¨äººã€è§†è§‰ |
| **Intel NUC** | è¿·ä½ PC | Core i5/i7 | è¾¹ç¼˜ç½‘å…³ |
| **Raspberry Pi** | SBC | 1.8GHz ARM | æ•™è‚²ã€åŸå‹ |
| **Coral Dev Board** | Edge TPU | 4 TOPS | IoTæ¨ç† |
| **HiKey 970** | å¼€å‘æ¿ | NPU | ç§»åŠ¨ç«¯AI |
| **BeagleBone AI** | å·¥ä¸šæ¿ | 8 TOPS | å·¥ä¸šæ§åˆ¶ |

### æ¨èè®ºæ–‡ä¸æŠ¥å‘Š

1. **ã€ŠEdge Computing: Vision and Challengesã€‹** - IEEE IoT Journal
   - è¾¹ç¼˜è®¡ç®—ç»¼è¿°ï¼Œå®šä¹‰æ ¸å¿ƒæŒ‘æˆ˜

2. **ã€ŠThe Emerging Landscape of Edge Computingã€‹** - ACM GETMobile
   - è¾¹ç¼˜è®¡ç®—ç”Ÿæ€ç³»ç»Ÿåˆ†æ

3. **ã€ŠMEC in 5G Networksã€‹** - ETSI White Paper
   - 5G MECæŠ€æœ¯ç™½çš®ä¹¦

4. **ã€ŠArchitectural Imperatives for Edge Computingã€‹** - IEEE Cloud Computing
   - è¾¹ç¼˜è®¡ç®—æ¶æ„è®¾è®¡åŸåˆ™

## ğŸ”— å…³è”çŸ¥è¯†

```mermaid
flowchart TB
    subgraph C02_Edge_Computing[è¾¹ç¼˜è®¡ç®—]
        Edge_Hardware[è¾¹ç¼˜ç¡¬ä»¶]
        Edge_AI[è¾¹ç¼˜AI]
        Edge_Orchestration[è¾¹ç¼˜ç¼–æ’]
        Edge_Sync[è¾¹ç¼˜äº‘ååŒ]
    end
    
    subgraph B01_Hardware[ç¡¬ä»¶æ¶æ„]
        C01_Server_Design[[C01 æœåŠ¡å™¨è®¾è®¡]]
        C03_Energy_Efficiency[[C03 èƒ½æ•ˆä¼˜åŒ–]]
    end
    
    subgraph B08_Network[ç½‘ç»œæ ˆ]
        C01_TCPIP[[C01 TCP/IPä¼˜åŒ–]]
        C03_Zero_Trust[[C03 é›¶ä¿¡ä»»ç½‘ç»œ]]
    end
    
    subgraph B09_Virtualization[è™šæ‹ŸåŒ–]
        C02_Container_Runtime[[C02 å®¹å™¨è¿è¡Œæ—¶]]
        C03_Serverless[[C03 Serverlessæ¶æ„]]
    end
    
    subgraph B10_Cloud[äº‘å¹³å°]
        C01_Multi_Cloud[[C01 å¤šäº‘ç­–ç•¥]]
    end
    
    C02_Edge_Computing --> C01_Server_Design
    C02_Edge_Computing --> C03_Energy_Efficiency
    C02_Edge_Computing --> C01_TCPIP
    C02_Edge_Computing --> C03_Zero_Trust
    C02_Edge_Computing --> C02_Container_Runtime
    C02_Edge_Computing -.-> C03_Serverless
    C02_Edge_Computing --> C01_Multi_Cloud
    
    Edge_Hardware --> C01_Server_Design
    Edge_AI -.-> C03_Energy_Efficiency
    Edge_Orchestration --> C02_Container_Runtime
    Edge_Sync --> C01_TCPIP
```

### ä¸Šæ¸¸ä¾èµ–

| å…³è”é¢†åŸŸ | ä¾èµ–å…³ç³» | è¯´æ˜ |
|---------|---------|------|
| **B01_Hardware_Arch/C01_Server_Design** | ä¾èµ– | è¾¹ç¼˜èŠ‚ç‚¹ç¡¬ä»¶è®¾è®¡åŸºç¡€ |
| **B01_Hardware_Arch/C03_Energy_Efficiency** | ä¾èµ– | è¾¹ç¼˜è®¾å¤‡åŠŸè€—ä¼˜åŒ– |
| **B08_Network_Stack/C01_TCPIP_Optimization** | ä¾èµ– | è¾¹ç¼˜ç½‘ç»œé€šä¿¡ä¼˜åŒ– |

### ä¸‹æ¸¸åº”ç”¨

| å…³è”é¢†åŸŸ | å…³ç³»ç±»å‹ | è¯´æ˜ |
|---------|---------|------|
| **B09_Virtualization/C02_Container_Runtimes** | è¢«ä¾èµ– | è¾¹ç¼˜å®¹å™¨åŒ–éƒ¨ç½² |
| **B10_Cloud_Platforms/C01_Multi-Cloud_Strategies** | ååŒ | è¾¹ç¼˜äº‘ååŒæ¶æ„ |
| **A05_Spec_Expertise/B01_AI_LLM_Engineering** | ååŒ | è¾¹ç¼˜AIæ¨¡å‹éƒ¨ç½² |

## ğŸ’¡ å­¦ä¹ å»ºè®®

### å…¥é—¨è·¯å¾„ï¼ˆ1-2ä¸ªæœˆï¼‰

**ç¬¬1-2å‘¨ï¼šæ¦‚å¿µå»ºç«‹**
- é˜…è¯»è¾¹ç¼˜è®¡ç®—ç»¼è¿°è®ºæ–‡
- ç†è§£è¾¹ç¼˜ä¸äº‘çš„åŒºåˆ«å’Œè”ç³»
- å­¦ä¹ 5G MECåŸºç¡€çŸ¥è¯†

**ç¬¬3-4å‘¨ï¼šåŠ¨æ‰‹å®è·µ**
- æ­å»ºRaspberry Piè¾¹ç¼˜ç½‘å…³
- éƒ¨ç½²K3sè½»é‡çº§Kubernetes
- å®ç°ç®€å•çš„ä¼ æ„Ÿå™¨æ•°æ®é‡‡é›†

**ç¬¬5-6å‘¨ï¼šè¾¹ç¼˜AIå…¥é—¨**
- å­¦ä¹ æ¨¡å‹é‡åŒ–ä¸å‹ç¼©
- åœ¨è¾¹ç¼˜è®¾å¤‡éƒ¨ç½²TFLiteæ¨¡å‹
- å®ç°å›¾åƒåˆ†ç±»æˆ–ç›®æ ‡æ£€æµ‹

**ç¬¬7-8å‘¨ï¼šç³»ç»Ÿé›†æˆ**
- æ­å»ºè¾¹ç¼˜-äº‘ååŒæ¶æ„
- å®ç°æ•°æ®åŒæ­¥ä¸ç¦»çº¿è‡ªæ²»
- é…ç½®ç›‘æ§ä¸å‘Šè­¦

### è¿›é˜¶æ–¹å‘

1. **è¾¹ç¼˜ç½‘ç»œä¼˜åŒ–**
   - ç ”ç©¶TSNï¼ˆæ—¶é—´æ•æ„Ÿç½‘ç»œï¼‰
   - 5Gç½‘ç»œåˆ‡ç‰‡ä¸è¾¹ç¼˜éƒ¨ç½²
   - è¾¹ç¼˜DNSä¸æµé‡è°ƒåº¦

2. **è¾¹ç¼˜å®‰å…¨**
   - è¾¹ç¼˜è®¾å¤‡å®‰å…¨å¯åŠ¨
   - é›¶ä¿¡ä»»è¾¹ç¼˜æ¶æ„
   - å®‰å…¨å¤šæ–¹è®¡ç®—åœ¨è¾¹ç¼˜çš„åº”ç”¨

3. **å¼‚æ„è¾¹ç¼˜è®¡ç®—**
   - GPU/DPUåœ¨è¾¹ç¼˜çš„åº”ç”¨
   - å­˜ç®—ä¸€ä½“è¾¹ç¼˜æ¶æ„
   - è”é‚¦å­¦ä¹ ä¸è¾¹ç¼˜ååŒ

### å®è·µé¡¹ç›®å»ºè®®

1. **æ™ºèƒ½å·¥å‚è¾¹ç¼˜ç½‘å…³**
   - å¤šåè®®å·¥ä¸šè®¾å¤‡æ¥å…¥
   - å®æ—¶è´¨é‡æ£€æµ‹AI
   - è®¾å¤‡é¢„æµ‹æ€§ç»´æŠ¤

2. **æ™ºæ…§é›¶å”®è¾¹ç¼˜èŠ‚ç‚¹**
   - å®¢æµåˆ†æç³»ç»Ÿ
   - æ™ºèƒ½è´§æ¶ç›‘æ§
   - è¾¹ç¼˜POSç³»ç»Ÿ

3. **è½¦è½½è¾¹ç¼˜è®¡ç®—å¹³å°**
   - å¤šæ‘„åƒå¤´èåˆ
   - å®æ—¶éšœç¢ç‰©æ£€æµ‹
   - è½¦äº‘ååŒæ•°æ®ä¸Šä¼ 

---

*æœ€åæ›´æ–°: 2026-01-30*  
*ç»´æŠ¤è€…: Infrastructure Team*

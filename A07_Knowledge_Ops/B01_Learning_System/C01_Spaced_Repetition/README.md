# C01_Spaced_Repetition - é—´éš”é‡å¤

> åŸºäºè®¤çŸ¥ç§‘å­¦çš„é«˜æ•ˆè®°å¿†ä¸çŸ¥è¯†å†…åŒ–æ–¹æ³•è®º

---

## 1. ä¸»é¢˜å®šä½

### 1.1 å®šä¹‰ä¸èƒŒæ™¯

é—´éš”é‡å¤ï¼ˆSpaced Repetitionï¼‰æ˜¯ä¸€ç§åŸºäºè®¤çŸ¥å¿ƒç†å­¦å’Œé—å¿˜æ›²çº¿ç†è®ºçš„å­¦ä¹ æŠ€æœ¯ï¼Œé€šè¿‡åœ¨ç‰¹å®šæ—¶é—´é—´éš”å†…é‡å¤å¤ä¹ å­¦ä¹ ææ–™ï¼Œä»¥ä¼˜åŒ–é•¿æœŸè®°å¿†çš„ä¿æŒå’Œæ£€ç´¢æ•ˆç‡ã€‚è¿™ä¸€æ–¹æ³•çš„æ ¸å¿ƒæ€æƒ³æ˜¯ï¼šä¸å…¶ä¸€æ¬¡æ€§å¤§é‡å­¦ä¹ ï¼ˆå¡«é¸­å¼å­¦ä¹ ï¼‰ï¼Œä¸å¦‚å°†å­¦ä¹ æ—¶é—´åˆ†æ•£åˆ°å¤šä¸ªé—´éš”ä¸­ï¼Œè¿™æ ·å¯ä»¥æ˜¾è‘—æé«˜è®°å¿†çš„æŒä¹…æ€§ã€‚

é—´éš”é‡å¤çš„ç†è®ºåŸºç¡€æœ€æ—©å¯ä»¥è¿½æº¯åˆ°1885å¹´å¾·å›½å¿ƒç†å­¦å®¶èµ«å°”æ›¼Â·è‰¾å®¾æµ©æ–¯ï¼ˆHermann Ebbinghausï¼‰çš„é—å¿˜æ›²çº¿ç ”ç©¶ã€‚è‰¾å®¾æµ©æ–¯å‘ç°ï¼Œäººä»¬å¯¹æ–°å­¦ä¹ å†…å®¹çš„é—å¿˜é€Ÿåº¦æœ€åˆéå¸¸å¿«ï¼Œä½†ä¼šéšç€æ—¶é—´çš„æ¨ç§»è€Œé€æ¸å‡ç¼“ã€‚å¦‚æœåœ¨é—å¿˜å‘ç”Ÿä¹‹å‰è¿›è¡Œå¤ä¹ ï¼Œå°±å¯ä»¥æœ‰æ•ˆåœ°é‡ç½®é—å¿˜æ›²çº¿ï¼Œå»¶é•¿è®°å¿†ä¿æŒæ—¶é—´ã€‚

åœ¨ç°ä»£çŸ¥è¯†ç®¡ç†é¢†åŸŸï¼Œé—´éš”é‡å¤å·²æˆä¸ºä¸ªäººçŸ¥è¯†ç®¡ç†ç³»ç»Ÿï¼ˆPKMï¼‰çš„æ ¸å¿ƒç»„ä»¶ï¼Œè¢«å¹¿æ³›åº”ç”¨äºè¯­è¨€å­¦ä¹ ã€åŒ»å­¦æ•™è‚²ã€æ³•å¾‹è€ƒè¯•å‡†å¤‡ä»¥åŠæŠ€æœ¯çŸ¥è¯†çš„é•¿æœŸä¿æŒã€‚

### 1.2 æ ¸å¿ƒä»·å€¼ä¸»å¼ 

| ç»´åº¦ | ä»·å€¼æè¿° |
|------|----------|
| **æ•ˆç‡æå‡** | ç›¸æ¯”ä¼ ç»Ÿé‡å¤å­¦ä¹ ï¼Œå¯èŠ‚çœ30%-50%çš„å­¦ä¹ æ—¶é—´ |
| **è®°å¿†æŒä¹…** | é€šè¿‡ç®—æ³•ä¼˜åŒ–ï¼Œå®ç°æ•°å¹´ç”šè‡³ç»ˆèº«çš„çŸ¥è¯†ä¿æŒ |
| **è®¤çŸ¥è´Ÿè·ç®¡ç†** | åªåœ¨éœ€è¦å¤ä¹ æ—¶æé†’ï¼Œé¿å…è¿‡åº¦å­¦ä¹ å¸¦æ¥çš„è®¤çŸ¥ç–²åŠ³ |
| **é‡åŒ–è¿½è¸ª** | æä¾›å¯è§†åŒ–çš„å­¦ä¹ è¿›åº¦å’Œè®°å¿†å¼ºåº¦æŒ‡æ ‡ |
| **ä¸ªæ€§åŒ–é€‚åº”** | æ ¹æ®ä¸ªä½“è®°å¿†è¡¨ç°åŠ¨æ€è°ƒæ•´å¤ä¹ é—´éš” |

### 1.3 é€‚ç”¨åœºæ™¯

- **è¯­è¨€è¯æ±‡ç§¯ç´¯**ï¼šé•¿æœŸä¿æŒæ•°ä¸‡ä¸ªå¤–è¯­å•è¯çš„è®°å¿†
- **ä¸“ä¸šçŸ¥è¯†å†…åŒ–**ï¼šåŒ»å­¦ã€æ³•å¾‹ã€å·¥ç¨‹ç­‰éœ€è¦ç²¾ç¡®è®°å¿†çš„ä¸“ä¸šé¢†åŸŸ
- **æŠ€æœ¯æ¦‚å¿µæŒæ¡**ï¼šç¼–ç¨‹è¯­è¨€è¯­æ³•ã€è®¾è®¡æ¨¡å¼ã€ç®—æ³•åŸç†ç­‰æŠ€æœ¯çŸ¥è¯†
- **è€ƒè¯•å‡†å¤‡**ï¼šéœ€è¦é•¿æœŸè®°å¿†å¤§é‡ä¿¡æ¯çš„èµ„æ ¼è€ƒè¯•
- **ç»ˆèº«å­¦ä¹ **ï¼šæ„å»ºä¸ªäººçŸ¥è¯†åº“çš„æŒç»­ç»´æŠ¤

---

## 2. æ ¸å¿ƒæ¦‚å¿µ

### 2.1 é—å¿˜æ›²çº¿ï¼ˆForgetting Curveï¼‰

è‰¾å®¾æµ©æ–¯é—å¿˜æ›²çº¿æè¿°äº†è®°å¿†ä¿æŒç‡éšæ—¶é—´æ¨ç§»è€Œä¸‹é™çš„é€Ÿç‡ã€‚åœ¨æ²¡æœ‰å¤ä¹ çš„æƒ…å†µä¸‹ï¼Œæ–°å­¦ä¿¡æ¯çš„ä¿æŒç‡éµå¾ªæŒ‡æ•°è¡°å‡æ¨¡å¼ï¼š

```
ä¿æŒç‡ R(t) = e^(-t/S)

å…¶ä¸­ï¼š
- t: è‡ªå­¦ä¹ ä»¥æ¥çš„æ—¶é—´
- S: è®°å¿†å¼ºåº¦ï¼ˆä¸å¤ä¹ æ¬¡æ•°æ­£ç›¸å…³ï¼‰
```

**å…³é”®æ´å¯Ÿ**ï¼š
- å­¦ä¹ å20åˆ†é’Ÿï¼Œè®°å¿†ä¿æŒçº¦58%
- å­¦ä¹ å1å°æ—¶ï¼Œè®°å¿†ä¿æŒçº¦44%
- å­¦ä¹ å1å¤©ï¼Œè®°å¿†ä¿æŒçº¦36%
- å­¦ä¹ å1å‘¨ï¼Œè®°å¿†ä¿æŒçº¦25%
- å­¦ä¹ å1ä¸ªæœˆï¼Œè®°å¿†ä¿æŒçº¦21%

é€šè¿‡åœ¨å…³é”®æ—¶é—´ç‚¹è¿›è¡Œå¤ä¹ ï¼Œå¯ä»¥å°†é—å¿˜æ›²çº¿"é‡ç½®"åˆ°æ›´é«˜æ°´å¹³ï¼Œå¹¶é€æ­¥å»¶é•¿è®°å¿†ä¿æŒæ—¶é—´ã€‚

### 2.2 é—´éš”æ•ˆåº”ï¼ˆSpacing Effectï¼‰

é—´éš”æ•ˆåº”æ˜¯è®¤çŸ¥å¿ƒç†å­¦ä¸­è¢«æœ€å¹¿æ³›éªŒè¯çš„å­¦ä¹ ç°è±¡ä¹‹ä¸€ã€‚ç ”ç©¶è¡¨æ˜ï¼Œå°†å­¦ä¹ æ—¶é—´åˆ†æ•£åˆ°å¤šä¸ªé—´éš”ä¸­ï¼Œæ¯”é›†ä¸­å­¦ä¹ ï¼ˆå¡«é¸­å¼å­¦ä¹ ï¼‰èƒ½äº§ç”Ÿæ›´å¥½çš„é•¿æœŸè®°å¿†æ•ˆæœã€‚

**åŸç†æœºåˆ¶**ï¼š
1. **ç¼–ç å˜å¼‚æ€§**ï¼šä¸åŒæ—¶é—´ã€ä¸åŒæƒ…å¢ƒä¸‹çš„å¤ä¹ äº§ç”Ÿæ›´ä¸°å¯Œçš„è®°å¿†ç¼–ç 
2. **æå–å¼ºåº¦**ï¼šæˆåŠŸä»é•¿æœŸè®°å¿†ä¸­æå–ä¿¡æ¯ä¼šå¢å¼ºè¯¥è®°å¿†çš„å­˜å‚¨å¼ºåº¦
3. **ä¸Šä¸‹æ–‡é‡æ„**ï¼šæ—¶é—´é—´éš”å…è®¸å¤§è„‘åœ¨ä¸åŒè®¤çŸ¥çŠ¶æ€ä¸‹å¤„ç†ä¿¡æ¯

### 2.3 é—´éš”é‡å¤ç®—æ³•

#### 2.3.1 SM-2ç®—æ³•

SuperMemo-2ç®—æ³•æ˜¯ç”±Piotr Wozniakå¼€å‘çš„æœ€å¹¿æ³›ä½¿ç”¨çš„é—´éš”é‡å¤ç®—æ³•ï¼š

```
ç®—æ³•å‚æ•°ï¼š
- EF (Easiness Factor): ç®€æ˜“åº¦å› å­ï¼Œåˆå§‹å€¼2.5
- I (Interval): å¤ä¹ é—´éš”
- n: å¤ä¹ æ¬¡æ•°

ç®—æ³•æµç¨‹ï¼š
1. é¦–æ¬¡å­¦ä¹ ï¼šI(1) = 1å¤©
2. ç¬¬äºŒæ¬¡å¤ä¹ ï¼šI(2) = 6å¤©
3. ç¬¬næ¬¡å¤ä¹ ï¼ˆn>2ï¼‰ï¼šI(n) = I(n-1) Ã— EF

4. è´¨é‡è¯„åˆ†ï¼ˆQï¼Œ0-5åˆ†ï¼‰ï¼š
   - 5: å®Œç¾å›ç­”
   - 4: æ­£ç¡®å›ç­”ï¼Œç¨æœ‰çŠ¹è±«
   - 3: æ­£ç¡®å›ç­”ï¼Œæœ‰å›°éš¾
   - 2: ä¸æ­£ç¡®å›ç­”ï¼Œæç¤ºåæ­£ç¡®
   - 1: ä¸æ­£ç¡®å›ç­”ï¼Œä½†çœ‹èµ·æ¥ç†Ÿæ‚‰
   - 0: å®Œå…¨å¿˜è®°

5. EFæ›´æ–°ï¼š
   EF' = EF + (0.1 - (5-Q) Ã— (0.08 + (5-Q) Ã— 0.02))
   å¦‚æœEF' < 1.3ï¼Œåˆ™è®¾EF' = 1.3
```

#### 2.3.2 è‡ªç”±é—´éš”ç®—æ³•ï¼ˆFSRSï¼‰

ç°ä»£é—´éš”é‡å¤è½¯ä»¶å¦‚Ankié‡‡ç”¨äº†æ›´å¤æ‚çš„Free Spaced Repetition Schedulerç®—æ³•ï¼š

```
FSRSä½¿ç”¨å››ä¸ªè®°å¿†çŠ¶æ€å‚æ•°ï¼š
- ç¨³å®šæ€§ï¼ˆStabilityï¼‰ï¼šè®°å¿†ä¿æŒçš„æ¦‚ç‡åŠè¡°æœŸ
- å¯æ£€ç´¢æ€§ï¼ˆRetrievabilityï¼‰ï¼šå½“å‰èƒ½å¤Ÿå›å¿†çš„æ¦‚ç‡
- éš¾åº¦ï¼ˆDifficultyï¼‰ï¼šé¡¹ç›®çš„å†…åœ¨éš¾åº¦
- æœŸæœ›ä¿ç•™ç‡ï¼ˆDesired Retentionï¼‰ï¼šç”¨æˆ·è®¾å®šçš„ç›®æ ‡ä¿ç•™æ¦‚ç‡

çŠ¶æ€è½¬æ¢ï¼š
R = e^(-t/S)  # å¯æ£€ç´¢æ€§éšæ—¶é—´è¡°å‡
S' = S Ã— (1 + a Ã— R^b Ã— D^c)  # æˆåŠŸå›å¿†åç¨³å®šæ€§å¢é•¿
D' = D + d Ã— (1 - R)  # å¤±è´¥å›å¿†åéš¾åº¦å¢åŠ 
```

### 2.4 å¡ç‰‡è®¾è®¡åŸåˆ™

æœ‰æ•ˆçš„é—´éš”é‡å¤å¡ç‰‡åº”éµå¾ªä»¥ä¸‹è®¾è®¡åŸåˆ™ï¼š

#### 2.4.1 åŸå­æ€§åŸåˆ™

æ¯ä¸ªå¡ç‰‡åº”åªæµ‹è¯•ä¸€ä¸ªçŸ¥è¯†ç‚¹æˆ–æ¦‚å¿µï¼š

```markdown
âŒ ä¸è‰¯ç¤ºä¾‹ï¼š
Q: Pythonä¸­çš„åˆ—è¡¨å’Œå…ƒç»„æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿå®ƒä»¬çš„æ€§èƒ½ç‰¹ç‚¹å’Œä½¿ç”¨åœºæ™¯æ˜¯ä»€ä¹ˆï¼Ÿ

âœ… è‰¯å¥½ç¤ºä¾‹ï¼š
å¡ç‰‡1ï¼š
Q: Pythonä¸­åˆ—è¡¨(list)å’Œå…ƒç»„(tuple)çš„æ ¹æœ¬åŒºåˆ«æ˜¯ä»€ä¹ˆï¼Ÿ
A: åˆ—è¡¨æ˜¯å¯å˜çš„(mutable)ï¼Œå…ƒç»„æ˜¯ä¸å¯å˜çš„(immutable)ã€‚

å¡ç‰‡2ï¼š
Q: Pythonå…ƒç»„ç›¸æ¯”åˆ—è¡¨åœ¨ä»€ä¹ˆæ“ä½œä¸Šé€šå¸¸æ›´å¿«ï¼Ÿ
A: è¿­ä»£(iteration)å’Œç´¢å¼•è®¿é—®(indexing)æ“ä½œã€‚
```

#### 2.4.2 ç²¾ç¡®æ€§åŸåˆ™

ç­”æ¡ˆåº”è¯¥ç²¾ç¡®ã€æ— æ­§ä¹‰ï¼š

```markdown
âŒ ä¸è‰¯ç¤ºä¾‹ï¼š
Q: TCPå’ŒUDPçš„åŒºåˆ«æ˜¯ä»€ä¹ˆï¼Ÿ
A: TCPå¯é ï¼ŒUDPä¸å¯é 

âœ… è‰¯å¥½ç¤ºä¾‹ï¼š
Q: TCPå’ŒUDPåœ¨è¿æ¥å»ºç«‹æ–¹é¢çš„ä¸»è¦åŒºåˆ«æ˜¯ä»€ä¹ˆï¼Ÿ
A: TCPæ˜¯é¢å‘è¿æ¥çš„åè®®ï¼Œéœ€è¦é€šè¿‡ä¸‰æ¬¡æ¡æ‰‹å»ºç«‹è¿æ¥ï¼›
   UDPæ˜¯æ— è¿æ¥åè®®ï¼Œä¸éœ€è¦é¢„å…ˆå»ºç«‹è¿æ¥å³å¯å‘é€æ•°æ®ã€‚
```

#### 2.4.3 ä¸Šä¸‹æ–‡åŸåˆ™

æä¾›è¶³å¤Ÿçš„ä¸Šä¸‹æ–‡ä¿¡æ¯ï¼Œé¿å…å­¤ç«‹çš„è®°å¿†ï¼š

```markdown
âœ… ç¤ºä¾‹ï¼š
Q: [è®¡ç®—æœºç½‘ç»œ-ä¼ è¾“å±‚] TCPä¸‰æ¬¡æ¡æ‰‹çš„ç¬¬ä¸‰æ­¥å®¢æˆ·ç«¯å‘é€ä»€ä¹ˆï¼Ÿ
A: ACK=1, seq=x+1, ack=y+1
   ï¼ˆå…¶ä¸­xæ˜¯å®¢æˆ·ç«¯åˆå§‹åºåˆ—å·ï¼Œyæ˜¯æœåŠ¡å™¨åˆå§‹åºåˆ—å·ï¼‰
```

### 2.5 å¤ä¹ ç­–ç•¥

#### 2.5.1 æ¯æ—¥å¤ä¹ é‡æ§åˆ¶

```python
# è®¡ç®—æ¯æ—¥å¤ä¹ é‡
def calculate_daily_review(new_cards_per_day, average_retention, days):
    """
    ä¼°ç®—æ¯æ—¥å¤ä¹ å¡ç‰‡æ•°é‡
    
    å‚æ•°:
    - new_cards_per_day: æ¯å¤©æ–°å­¦å¡ç‰‡æ•°
    - average_retention: å¹³å‡ä¿ç•™ç‡(0-1)
    - days: å­¦ä¹ å¤©æ•°
    
    è¿”å›: æ¯æ—¥å¹³å‡å¤ä¹ æ•°é‡
    """
    # ç®€åŒ–æ¨¡å‹ï¼šå¤ä¹ é‡ â‰ˆ æ–°å¡ç‰‡æ•° Ã— å­¦ä¹ å¤©æ•° Ã— (1-ä¿ç•™ç‡) Ã— è¡°å‡å› å­
    import math
    decay_factor = 1 / math.log(days + 2)
    daily_reviews = new_cards_per_day * days * (1 - average_retention) * decay_factor
    return int(daily_reviews)

# ç¤ºä¾‹ï¼šæ¯å¤©20å¼ æ–°å¡ï¼Œ90%ä¿ç•™ç‡ï¼Œå­¦ä¹ 30å¤©
reviews = calculate_daily_review(20, 0.90, 30)
print(f"æ¯æ—¥é¢„è®¡å¤ä¹ é‡: {reviews} å¼ å¡ç‰‡")
```

#### 2.5.2 æœ€ä½³å¤ä¹ æ—¶é—´

ç ”ç©¶è¡¨æ˜ï¼Œé—´éš”é‡å¤çš„æœ€ä½³å¤ä¹ æ—¶é—´å…·æœ‰ä»¥ä¸‹ç‰¹å¾ï¼š

| æ—¶é—´æ®µ | æ•ˆæœè¯„çº§ | åŸå› åˆ†æ |
|--------|----------|----------|
| æ—©æ™¨ï¼ˆèµ·åºŠå1-2å°æ—¶ï¼‰ | â­â­â­â­â­ | è®¤çŸ¥èµ„æºå……è¶³ï¼Œå¹²æ‰°æœ€å°‘ |
| åˆåï¼ˆåˆé¤å1-2å°æ—¶ï¼‰ | â­â­â­ | å¯èƒ½å­˜åœ¨é¤åå›°å€¦ |
| æ™šé—´ï¼ˆç¡å‰1-2å°æ—¶ï¼‰ | â­â­â­â­ | ç¡çœ æœ‰åŠ©äºè®°å¿†å·©å›º |
| ç¢ç‰‡åŒ–æ—¶é—´ | â­â­â­ | é€‚åˆçŸ­å¤ä¹ ï¼Œä½†æ·±åº¦æœ‰é™ |

---

## 3. æŠ€æœ¯å®è·µ

### 3.1 é—´éš”é‡å¤ç³»ç»Ÿå®ç°

#### 3.1.1 æ ¸å¿ƒè°ƒåº¦å™¨å®ç°

```python
import datetime
from dataclasses import dataclass, field
from typing import List, Optional
import json

@dataclass
class ReviewCard:
    """é—´éš”é‡å¤å¡ç‰‡æ•°æ®æ¨¡å‹"""
    id: str
    front: str  # å¡ç‰‡æ­£é¢ï¼ˆé—®é¢˜ï¼‰
    back: str   # å¡ç‰‡èƒŒé¢ï¼ˆç­”æ¡ˆï¼‰
    tags: List[str] = field(default_factory=list)
    
    # SM-2ç®—æ³•å‚æ•°
    ef: float = 2.5  # ç®€æ˜“åº¦å› å­
    interval: int = 0  # å½“å‰é—´éš”ï¼ˆå¤©ï¼‰
    repetitions: int = 0  # è¿ç»­æˆåŠŸå¤ä¹ æ¬¡æ•°
    
    # çŠ¶æ€è¿½è¸ª
    due_date: datetime.date = field(default_factory=datetime.date.today)
    last_reviewed: Optional[datetime.date] = None
    total_reviews: int = 0
    successful_reviews: int = 0
    
    def schedule_next_review(self, quality: int):
        """
        æ ¹æ®SM-2ç®—æ³•å®‰æ’ä¸‹ä¸€æ¬¡å¤ä¹ 
        
        å‚æ•°:
            quality: å›å¿†è´¨é‡è¯„åˆ†(0-5)
        """
        self.total_reviews += 1
        self.last_reviewed = datetime.date.today()
        
        if quality < 3:
            # å›å¿†å¤±è´¥ï¼Œé‡ç½®é—´éš”
            self.repetitions = 0
            self.interval = 1
        else:
            # å›å¿†æˆåŠŸ
            self.successful_reviews += 1
            self.repetitions += 1
            
            if self.repetitions == 1:
                self.interval = 1
            elif self.repetitions == 2:
                self.interval = 6
            else:
                self.interval = int(self.interval * self.ef)
        
        # æ›´æ–°ç®€æ˜“åº¦å› å­
        self.ef = self.ef + (0.1 - (5 - quality) * (0.08 + (5 - quality) * 0.02))
        self.ef = max(1.3, self.ef)  # æœ€ä½EFä¸º1.3
        
        # è®¡ç®—ä¸‹æ¬¡å¤ä¹ æ—¥æœŸ
        self.due_date = datetime.date.today() + datetime.timedelta(days=self.interval)
    
    def is_due(self) -> bool:
        """æ£€æŸ¥å¡ç‰‡æ˜¯å¦åˆ°æœŸ"""
        return self.due_date <= datetime.date.today()
    
    def get_retrievability(self) -> float:
        """è®¡ç®—å½“å‰å¯æ£€ç´¢æ€§ï¼ˆåŸºäºé—å¿˜æ›²çº¿ï¼‰"""
        if self.last_reviewed is None:
            return 0.0
        days_since_review = (datetime.date.today() - self.last_reviewed).days
        # ç®€åŒ–æ¨¡å‹ï¼šR = e^(-t/S)ï¼Œå‡è®¾Sä¸intervalæˆæ­£æ¯”
        import math
        stability = max(1, self.interval)
        return math.exp(-days_since_review / stability)


class SpacedRepetitionSystem:
    """é—´éš”é‡å¤ç³»ç»Ÿæ ¸å¿ƒç±»"""
    
    def __init__(self, data_file: str = "srs_data.json"):
        self.data_file = data_file
        self.cards: dict[str, ReviewCard] = {}
        self.load_data()
    
    def add_card(self, front: str, back: str, tags: List[str] = None) -> ReviewCard:
        """æ·»åŠ æ–°å¡ç‰‡"""
        import uuid
        card_id = str(uuid.uuid4())[:8]
        card = ReviewCard(
            id=card_id,
            front=front,
            back=back,
            tags=tags or []
        )
        self.cards[card_id] = card
        self.save_data()
        return card
    
    def get_due_cards(self) -> List[ReviewCard]:
        """è·å–æ‰€æœ‰åˆ°æœŸå¡ç‰‡"""
        return [card for card in self.cards.values() if card.is_due()]
    
    def get_new_cards(self, limit: int = 10) -> List[ReviewCard]:
        """è·å–æ–°å¡ç‰‡ï¼ˆæœªå¤ä¹ è¿‡ï¼‰"""
        new_cards = [card for card in self.cards.values() 
                     if card.total_reviews == 0]
        return new_cards[:limit]
    
    def review_card(self, card_id: str, quality: int):
        """å¤ä¹ ä¸€å¼ å¡ç‰‡"""
        if card_id not in self.cards:
            raise ValueError(f"å¡ç‰‡ä¸å­˜åœ¨: {card_id}")
        
        if not 0 <= quality <= 5:
            raise ValueError("è¯„åˆ†å¿…é¡»åœ¨0-5ä¹‹é—´")
        
        self.cards[card_id].schedule_next_review(quality)
        self.save_data()
    
    def get_stats(self) -> dict:
        """è·å–å­¦ä¹ ç»Ÿè®¡"""
        total = len(self.cards)
        due_today = len(self.get_due_cards())
        new_cards = len([c for c in self.cards.values() if c.total_reviews == 0])
        
        total_reviews = sum(c.total_reviews for c in self.cards.values())
        success_rate = 0
        if total_reviews > 0:
            successful = sum(c.successful_reviews for c in self.cards.values())
            success_rate = successful / total_reviews * 100
        
        return {
            "total_cards": total,
            "due_today": due_today,
            "new_cards": new_cards,
            "total_reviews": total_reviews,
            "success_rate": f"{success_rate:.1f}%"
        }
    
    def save_data(self):
        """ä¿å­˜æ•°æ®åˆ°æ–‡ä»¶"""
        data = {}
        for card_id, card in self.cards.items():
            data[card_id] = {
                "id": card.id,
                "front": card.front,
                "back": card.back,
                "tags": card.tags,
                "ef": card.ef,
                "interval": card.interval,
                "repetitions": card.repetitions,
                "due_date": card.due_date.isoformat(),
                "last_reviewed": card.last_reviewed.isoformat() if card.last_reviewed else None,
                "total_reviews": card.total_reviews,
                "successful_reviews": card.successful_reviews
            }
        
        with open(self.data_file, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)
    
    def load_data(self):
        """ä»æ–‡ä»¶åŠ è½½æ•°æ®"""
        try:
            with open(self.data_file, 'r', encoding='utf-8') as f:
                data = json.load(f)
            
            for card_id, card_data in data.items():
                card = ReviewCard(
                    id=card_data["id"],
                    front=card_data["front"],
                    back=card_data["back"],
                    tags=card_data.get("tags", []),
                    ef=card_data.get("ef", 2.5),
                    interval=card_data.get("interval", 0),
                    repetitions=card_data.get("repetitions", 0),
                    due_date=datetime.date.fromisoformat(card_data["due_date"]),
                    last_reviewed=datetime.date.fromisoformat(card_data["last_reviewed"]) if card_data.get("last_reviewed") else None,
                    total_reviews=card_data.get("total_reviews", 0),
                    successful_reviews=card_data.get("successful_reviews", 0)
                )
                self.cards[card_id] = card
        except FileNotFoundError:
            pass


# ä½¿ç”¨ç¤ºä¾‹
def demo_srs():
    """é—´éš”é‡å¤ç³»ç»Ÿæ¼”ç¤º"""
    srs = SpacedRepetitionSystem()
    
    # æ·»åŠ ä¸€äº›å­¦ä¹ å¡ç‰‡
    srs.add_card(
        front="TCPä¸‰æ¬¡æ¡æ‰‹çš„ä¸‰ä¸ªæ­¥éª¤æ˜¯ä»€ä¹ˆï¼Ÿ",
        back="1. SYN: å®¢æˆ·ç«¯å‘é€SYNåˆ°æœåŠ¡å™¨\\n2. SYN-ACK: æœåŠ¡å™¨å›å¤SYN-ACK\\n3. ACK: å®¢æˆ·ç«¯å‘é€ACKç¡®è®¤",
        tags=["networking", "tcp"]
    )
    
    srs.add_card(
        front="Pythonä¸­çš„GILæ˜¯ä»€ä¹ˆï¼Ÿ",
        back="GIL (Global Interpreter Lock) æ˜¯Pythonçš„å…¨å±€è§£é‡Šå™¨é”ï¼Œ\\nå®ƒç¡®ä¿ä»»ä½•æ—¶å€™åªæœ‰ä¸€ä¸ªçº¿ç¨‹åœ¨æ‰§è¡ŒPythonå­—èŠ‚ç ï¼Œ\\nè¿™ä½¿å¾—å¤šçº¿ç¨‹åœ¨CPUå¯†é›†å‹ä»»åŠ¡ä¸­æ— æ³•çœŸæ­£å®ç°å¹¶è¡Œã€‚",
        tags=["python", "concurrency"]
    )
    
    srs.add_card(
        front="HTTPçŠ¶æ€ç 404å’Œ500çš„åŒºåˆ«ï¼Ÿ",
        back="404 Not Found: æœåŠ¡å™¨æ‰¾ä¸åˆ°è¯·æ±‚çš„èµ„æºï¼ˆå®¢æˆ·ç«¯é”™è¯¯ï¼‰\\n500 Internal Server Error: æœåŠ¡å™¨å†…éƒ¨é”™è¯¯ï¼ˆæœåŠ¡å™¨ç«¯é”™è¯¯ï¼‰",
        tags=["http", "web"]
    )
    
    # æŸ¥çœ‹ç»Ÿè®¡
    print("=" * 50)
    print("å­¦ä¹ ç»Ÿè®¡:")
    stats = srs.get_stats()
    for key, value in stats.items():
        print(f"  {key}: {value}")
    
    # æ¨¡æ‹Ÿå¤ä¹ 
    print("\n" + "=" * 50)
    print("ä»Šæ—¥åˆ°æœŸå¡ç‰‡:")
    due_cards = srs.get_due_cards()
    for card in due_cards:
        print(f"\n[{card.id}] {card.front}")
        print(f"å½“å‰é—´éš”: {card.interval}å¤©, EF: {card.ef:.2f}")
        
        # æ¨¡æ‹Ÿå¤ä¹ è¯„åˆ†
        import random
        quality = random.randint(3, 5)  # å‡è®¾éƒ½è®°ä½äº†
        srs.review_card(card.id, quality)
        print(f"è¯„åˆ†: {quality}/5 -> ä¸‹æ¬¡å¤ä¹ : {card.due_date}")

if __name__ == "__main__":
    demo_srs()
```

#### 3.1.2 CLIå¤ä¹ ç•Œé¢

```python
import os
import sys
from typing import Optional

class ReviewCLI:
    """é—´éš”é‡å¤å‘½ä»¤è¡Œå¤ä¹ ç•Œé¢"""
    
    def __init__(self, srs: SpacedRepetitionSystem):
        self.srs = srs
        self.current_card: Optional[ReviewCard] = None
    
    def clear_screen(self):
        """æ¸…å±"""
        os.system('cls' if os.name == 'nt' else 'clear')
    
    def show_card_front(self, card: ReviewCard):
        """æ˜¾ç¤ºå¡ç‰‡æ­£é¢"""
        self.clear_screen()
        print("=" * 60)
        print("ğŸ“š é—´éš”é‡å¤å¤ä¹ ç³»ç»Ÿ")
        print("=" * 60)
        print(f"\nğŸ·ï¸ æ ‡ç­¾: {', '.join(card.tags) if card.tags else 'æ— '}")
        print(f"ğŸ“Š å·²å¤ä¹ : {card.total_reviews}æ¬¡ | è¿ç»­æˆåŠŸ: {card.repetitions}æ¬¡")
        print(f"ğŸ“… å½“å‰é—´éš”: {card.interval}å¤©")
        print("-" * 60)
        print("\nâ“ é—®é¢˜:")
        print(f"\n{card.front}")
        print("\n" + "-" * 60)
        input("\næŒ‰EnteræŸ¥çœ‹ç­”æ¡ˆ...")
    
    def show_card_back(self, card: ReviewCard) -> int:
        """æ˜¾ç¤ºå¡ç‰‡èƒŒé¢å¹¶è·å–è¯„åˆ†"""
        self.clear_screen()
        print("=" * 60)
        print("ğŸ“š é—´éš”é‡å¤å¤ä¹ ç³»ç»Ÿ")
        print("=" * 60)
        print(f"\nâ“ é—®é¢˜:\n{card.front}")
        print("\n" + "-" * 60)
        print(f"\nâœ… ç­”æ¡ˆ:\n{card.back}")
        print("\n" + "=" * 60)
        print("\nğŸ“Š è¯·è¯„ä¼°ä½ çš„å›å¿†è´¨é‡:")
        print("  [5] å®Œç¾ - ç«‹å³æ­£ç¡®å›ç­”ï¼Œæ¯«ä¸è´¹åŠ›")
        print("  [4] è‰¯å¥½ - æ­£ç¡®å›ç­”ï¼Œç¨æœ‰çŠ¹è±«")
        print("  [3] å›°éš¾ - æ­£ç¡®å›ç­”ï¼Œä½†æœ‰å›°éš¾")
        print("  [2] æ¨¡ç³Š - ä¸æ­£ç¡®ï¼Œä½†çœ‹èµ·æ¥ç†Ÿæ‚‰")
        print("  [1] é—å¿˜ - å®Œå…¨å¿˜è®°")
        print("  [0] é»‘åå• - å¡ç‰‡æœ‰é—®é¢˜ï¼Œéœ€è¦ä¿®æ”¹")
        print("-" * 60)
        
        while True:
            try:
                choice = input("\nä½ çš„è¯„åˆ† (0-5): ").strip()
                quality = int(choice)
                if 0 <= quality <= 5:
                    return quality
                else:
                    print("è¯·è¾“å…¥0-5ä¹‹é—´çš„æ•°å­—")
            except ValueError:
                print("è¯·è¾“å…¥æœ‰æ•ˆçš„æ•°å­—")
    
    def run_review_session(self):
        """è¿è¡Œå¤ä¹ ä¼šè¯"""
        due_cards = self.srs.get_due_cards()
        
        if not due_cards:
            print("ğŸ‰ æ­å–œï¼ä»Šå¤©æ²¡æœ‰åˆ°æœŸçš„å¡ç‰‡éœ€è¦å¤ä¹ ã€‚")
            return
        
        print(f"ğŸ“‹ ä»Šæ—¥å…±æœ‰ {len(due_cards)} å¼ å¡ç‰‡éœ€è¦å¤ä¹ ")
        input("æŒ‰Enterå¼€å§‹å¤ä¹ ...")
        
        reviewed_count = 0
        for card in due_cards:
            self.show_card_front(card)
            quality = self.show_card_back(card)
            
            if quality == 0:
                print("âš ï¸ å¡ç‰‡å·²æ ‡è®°ä¸ºéœ€è¦ä¿®æ”¹")
                continue
            
            old_interval = card.interval
            self.srs.review_card(card.id, quality)
            reviewed_count += 1
            
            print(f"\nâœ… å·²è®°å½•è¯„åˆ†: {quality}/5")
            print(f"   é—´éš”å˜åŒ–: {old_interval}å¤© -> {card.interval}å¤©")
            print(f"   ä¸‹æ¬¡å¤ä¹ : {card.due_date}")
            
            remaining = len(due_cards) - reviewed_count
            print(f"\nå‰©ä½™ {remaining} å¼ å¡ç‰‡")
            
            if remaining > 0:
                cont = input("\nç»§ç»­å¤ä¹ ? (Enterç»§ç»­, qé€€å‡º): ").strip().lower()
                if cont == 'q':
                    break
        
        print(f"\nğŸ‰ æœ¬æ¬¡å¤ä¹ å®Œæˆï¼å…±å¤ä¹  {reviewed_count} å¼ å¡ç‰‡")
        print("\nå­¦ä¹ ç»Ÿè®¡:")
        stats = self.srs.get_stats()
        for key, value in stats.items():
            print(f"  {key}: {value}")


def main():
    """ä¸»ç¨‹åºå…¥å£"""
    srs = SpacedRepetitionSystem()
    cli = ReviewCLI(srs)
    
    while True:
        print("\n" + "=" * 60)
        print("ğŸ“š é—´éš”é‡å¤ç³»ç»Ÿ")
        print("=" * 60)
        print("1. å¼€å§‹å¤ä¹ ")
        print("2. æ·»åŠ æ–°å¡ç‰‡")
        print("3. æŸ¥çœ‹ç»Ÿè®¡")
        print("4. é€€å‡º")
        
        choice = input("\nè¯·é€‰æ‹©: ").strip()
        
        if choice == "1":
            cli.run_review_session()
        elif choice == "2":
            front = input("é—®é¢˜: ").strip()
            back = input("ç­”æ¡ˆ: ").strip()
            tags_input = input("æ ‡ç­¾(ç”¨é€—å·åˆ†éš”): ").strip()
            tags = [t.strip() for t in tags_input.split(",") if t.strip()]
            srs.add_card(front, back, tags)
            print("âœ… å¡ç‰‡å·²æ·»åŠ ")
        elif choice == "3":
            stats = srs.get_stats()
            for key, value in stats.items():
                print(f"{key}: {value}")
        elif choice == "4":
            print("å†è§ï¼")
            break
        else:
            print("æ— æ•ˆé€‰æ‹©")


if __name__ == "__main__":
    main()
```

### 3.2 Ankié›†æˆä¸æ•°æ®å¯¼å…¥å¯¼å‡º

```python
import sqlite3
import zipfile
import xml.etree.ElementTree as ET
from pathlib import Path

class AnkiIntegration:
    """Ankiå¡ç‰‡åº“é›†æˆå·¥å…·"""
    
    ANKI_PACKAGE_EXT = ".apkg"
    
    @staticmethod
    def export_to_anki_format(cards: List[ReviewCard], output_path: str, deck_name: str = "My Deck"):
        """
        å°†å¡ç‰‡å¯¼å‡ºä¸ºAnkiå¯å¯¼å…¥çš„æ ¼å¼
        
        Ankiä½¿ç”¨SQLiteæ•°æ®åº“æ ¼å¼ï¼ŒåŒ…å«ä»¥ä¸‹ä¸»è¦è¡¨ï¼š
        - col: é›†åˆé…ç½®
        - notes: ç¬”è®°å†…å®¹
        - cards: å¡ç‰‡è°ƒåº¦ä¿¡æ¯
        - revlog: å¤ä¹ å†å²
        """
        # åˆ›å»ºä¸´æ—¶ç›®å½•
        temp_dir = Path(output_path).parent / "temp_anki"
        temp_dir.mkdir(exist_ok=True)
        
        db_path = temp_dir / "collection.anki2"
        
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()
        
        # åˆ›å»ºAnkiæ•°æ®åº“ç»“æ„
        cursor.executescript('''
            CREATE TABLE IF NOT EXISTS col (
                id INTEGER PRIMARY KEY,
                crt INTEGER, mod INTEGER, scm INTEGER, ver INTEGER, 
                dty INTEGER, usn INTEGER, ls INTEGER, conf TEXT,
                models TEXT, decks TEXT, dconf TEXT, tags TEXT
            );
            
            CREATE TABLE IF NOT EXISTS notes (
                id INTEGER PRIMARY KEY, guid TEXT, mid INTEGER, 
                mod INTEGER, usn INTEGER, tags TEXT, flds TEXT, 
                sfld TEXT, csum INTEGER, flags INTEGER, data TEXT
            );
            
            CREATE TABLE IF NOT EXISTS cards (
                id INTEGER PRIMARY KEY, nid INTEGER, did INTEGER, 
                ord INTEGER, mod INTEGER, usn INTEGER, type INTEGER,
                queue INTEGER, due INTEGER, ivl INTEGER, factor INTEGER,
                reps INTEGER, lapses INTEGER, left INTEGER, odue INTEGER,
                odid INTEGER, flags INTEGER, data TEXT
            );
            
            CREATE TABLE IF NOT EXISTS revlog (
                id INTEGER PRIMARY KEY, cid INTEGER, usn INTEGER,
                ease INTEGER, ivl INTEGER, lastIvl INTEGER, factor INTEGER,
                time INTEGER, type INTEGER
            );
        ''')
        
        # æ’å…¥å¡ç‰‡æ•°æ®
        import time
        timestamp = int(time.time() * 1000)
        
        for idx, card in enumerate(cards):
            note_id = timestamp + idx
            
            # æ’å…¥note
            fields = f"{card.front}\x1f{card.back}"  # \x1fæ˜¯å­—æ®µåˆ†éš”ç¬¦
            cursor.execute('''
                INSERT INTO notes (id, guid, mid, mod, usn, tags, flds, sfld, csum, flags, data)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (note_id, str(note_id), 1, timestamp, -1, ' '.join(card.tags), 
                  fields, card.front, 0, 0, ''))
            
            # æ’å…¥cardï¼ˆè°ƒåº¦ä¿¡æ¯ï¼‰
            card_id = timestamp * 10 + idx
            cursor.execute('''
                INSERT INTO cards (id, nid, did, ord, mod, usn, type, queue, 
                                  due, ivl, factor, reps, lapses, left, odue, odid, flags, data)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (card_id, note_id, 1, 0, timestamp, -1, 0, 0, 
                  0, card.interval, int(card.ef * 1000), card.total_reviews, 
                  card.total_reviews - card.successful_reviews, 0, 0, 0, 0, ''))
        
        conn.commit()
        conn.close()
        
        # åˆ›å»º.apkgæ–‡ä»¶ï¼ˆZIPæ ¼å¼ï¼‰
        with zipfile.ZipFile(output_path, 'w', zipfile.ZIP_DEFLATED) as zf:
            zf.write(db_path, "collection.anki2")
            # æ·»åŠ åª’ä½“æ–‡ä»¶ï¼ˆå¦‚æœæœ‰ï¼‰
        
        # æ¸…ç†ä¸´æ—¶æ–‡ä»¶
        import shutil
        shutil.rmtree(temp_dir)
        
        print(f"âœ… å·²å¯¼å‡º {len(cards)} å¼ å¡ç‰‡åˆ° {output_path}")
    
    @staticmethod
    def import_from_anki(apkg_path: str) -> List[ReviewCard]:
        """ä»AnkiåŒ…å¯¼å…¥å¡ç‰‡"""
        cards = []
        temp_dir = Path(apkg_path).parent / "temp_import"
        temp_dir.mkdir(exist_ok=True)
        
        # è§£å‹.apkgæ–‡ä»¶
        with zipfile.ZipFile(apkg_path, 'r') as zf:
            zf.extractall(temp_dir)
        
        db_path = temp_dir / "collection.anki2"
        if not db_path.exists():
            raise FileNotFoundError(f"æœªæ‰¾åˆ°Ankiæ•°æ®åº“: {db_path}")
        
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()
        
        # è¯»å–notesè¡¨
        cursor.execute("SELECT id, tags, flds FROM notes")
        for row in cursor.fetchall():
            note_id, tags_str, fields = row
            # è§£æå­—æ®µï¼ˆåˆ†éš”ç¬¦ä¸º\x1fï¼‰
            fields_list = fields.split('\x1f')
            if len(fields_list) >= 2:
                front, back = fields_list[0], fields_list[1]
                tags = tags_str.split() if tags_str else []
                
                card = ReviewCard(
                    id=str(note_id),
                    front=front,
                    back=back,
                    tags=tags
                )
                cards.append(card)
        
        conn.close()
        
        # æ¸…ç†
        import shutil
        shutil.rmtree(temp_dir)
        
        print(f"âœ… ä»Ankiå¯¼å…¥ {len(cards)} å¼ å¡ç‰‡")
        return cards
```

### 3.3 å¯è§†åŒ–åˆ†æ

```python
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
from datetime import datetime, timedelta
import numpy as np

class SRSAnalytics:
    """é—´éš”é‡å¤ç³»ç»Ÿåˆ†æå·¥å…·"""
    
    def __init__(self, srs: SpacedRepetitionSystem):
        self.srs = srs
    
    def plot_retention_curve(self):
        """ç»˜åˆ¶é—å¿˜æ›²çº¿å’Œå®é™…ä¿ç•™ç‡"""
        fig, ax = plt.subplots(figsize=(10, 6))
        
        # ç†è®ºé—å¿˜æ›²çº¿
        days = np.linspace(0, 30, 100)
        retention_theory = np.exp(-days / 5)  # å‡è®¾è®°å¿†å¼ºåº¦S=5
        
        ax.plot(days, retention_theory * 100, 'b--', label='ç†è®ºé—å¿˜æ›²çº¿ (S=5)')
        
        # å„å¡ç‰‡çš„ä¿ç•™ç‡
        for card in list(self.srs.cards.values())[:20]:  # æœ€å¤šæ˜¾ç¤º20å¼ 
            if card.last_reviewed:
                days_elapsed = (datetime.now().date() - card.last_reviewed).days
                retrievability = card.get_retrievability()
                ax.scatter([days_elapsed], [retrievability * 100], 
                          alpha=0.5, s=30, c='red')
        
        ax.set_xlabel('è‡ªä¸Šæ¬¡å¤ä¹ ä»¥æ¥çš„å¤©æ•°')
        ax.set_ylabel('ä¿ç•™ç‡ (%)')
        ax.set_title('é—å¿˜æ›²çº¿ä¸å¡ç‰‡ä¿ç•™ç‡åˆ†æ')
        ax.legend()
        ax.grid(True, alpha=0.3)
        ax.set_ylim(0, 105)
        
        plt.tight_layout()
        plt.savefig('retention_curve.png', dpi=150)
        plt.show()
    
    def plot_review_heatmap(self):
        """ç»˜åˆ¶å¤ä¹ çƒ­åŠ›å›¾"""
        # æ¨¡æ‹Ÿè¿‡å»30å¤©çš„å¤ä¹ æ•°æ®
        days = 30
        reviews_per_day = np.random.poisson(15, days)  # å¹³å‡æ¯å¤©15æ¬¡å¤ä¹ 
        
        fig, ax = plt.subplots(figsize=(12, 4))
        
        dates = [datetime.now() - timedelta(days=i) for i in range(days)]
        dates.reverse()
        
        colors = plt.cm.YlOrRd(np.linspace(0.2, 1, max(reviews_per_day) + 1))
        
        for i, (date, count) in enumerate(zip(dates, reviews_per_day)):
            color = colors[count] if count < len(colors) else colors[-1]
            ax.bar(i, count, color=color, width=0.8)
        
        ax.set_xlabel('æ—¥æœŸ')
        ax.set_ylabel('å¤ä¹ æ¬¡æ•°')
        ax.set_title('30å¤©å¤ä¹ çƒ­åŠ›å›¾')
        ax.set_xticks(range(0, days, 5))
        ax.set_xticklabels([(datetime.now() - timedelta(days=days-i-1)).strftime('%m-%d') 
                            for i in range(0, days, 5)])
        
        plt.tight_layout()
        plt.savefig('review_heatmap.png', dpi=150)
        plt.show()
    
    def plot_interval_distribution(self):
        """ç»˜åˆ¶é—´éš”åˆ†å¸ƒå›¾"""
        intervals = [card.interval for card in self.srs.cards.values() 
                     if card.interval > 0]
        
        if not intervals:
            print("æ²¡æœ‰é—´éš”æ•°æ®å¯æ˜¾ç¤º")
            return
        
        fig, ax = plt.subplots(figsize=(10, 6))
        
        bins = [0, 1, 3, 7, 14, 30, 90, 180, 365, max(intervals)+1]
        labels = ['1å¤©', '2-3å¤©', '4-7å¤©', '1-2å‘¨', '2å‘¨-1æœˆ', 
                  '1-3æœˆ', '3-6æœˆ', '6æœˆ-1å¹´', '1å¹´+']
        
        counts, _ = np.histogram(intervals, bins=bins)
        
        ax.bar(range(len(counts)), counts, color='steelblue', edgecolor='black')
        ax.set_xticks(range(len(labels)))
        ax.set_xticklabels(labels, rotation=45)
        ax.set_xlabel('å¤ä¹ é—´éš”')
        ax.set_ylabel('å¡ç‰‡æ•°é‡')
        ax.set_title('å¡ç‰‡é—´éš”åˆ†å¸ƒ')
        
        for i, count in enumerate(counts):
            if count > 0:
                ax.text(i, count + 0.5, str(count), ha='center')
        
        plt.tight_layout()
        plt.savefig('interval_distribution.png', dpi=150)
        plt.show()
```

---

## 4. èµ„æºç´¢å¼•

### 4.1 æ¨èè½¯ä»¶å·¥å…·

| å·¥å…·åç§° | å¹³å°æ”¯æŒ | ç‰¹ç‚¹ | é€‚ç”¨åœºæ™¯ |
|----------|----------|------|----------|
| **Anki** | Windows/Mac/Linux/iOS/Android | å¼€æºã€é«˜åº¦å¯å®šåˆ¶ã€æ’ä»¶ç”Ÿæ€ä¸°å¯Œ | ä¸“ä¸šå­¦ä¹ è€…ã€éœ€è¦æ·±åº¦å®šåˆ¶çš„ç”¨æˆ· |
| **RemNote** | Web/Windows/Mac/iOS/Android | åŒå‘é“¾æ¥+é—´éš”é‡å¤ç»“åˆã€ç¬”è®°å­¦ä¹ ä¸€ä½“åŒ– | çŸ¥è¯†ç®¡ç†+å­¦ä¹ ç»“åˆéœ€æ±‚ |
| **SuperMemo** | Windows | é—´éš”é‡å¤ç®—æ³•å‘æºåœ°ã€åŠŸèƒ½æœ€å…¨é¢ | æè‡´æ•ˆç‡è¿½æ±‚è€… |
| **Quizlet** | Web/iOS/Android | ç•Œé¢å‹å¥½ã€ç¤¾äº¤åŠŸèƒ½å¼º | å­¦ç”Ÿç¾¤ä½“ã€ç®€å•è®°å¿†éœ€æ±‚ |
| **Memrise** | Web/iOS/Android | æ¸¸æˆåŒ–è®¾è®¡ã€å®˜æ–¹è¯¾ç¨‹ä¸°å¯Œ | è¯­è¨€å­¦ä¹  |
| **Mochi Cards** | Web/Windows/Mac/Linux | ç®€æ´ä¼˜é›…ã€Markdownæ”¯æŒ | å–œæ¬¢ç®€æ´ç•Œé¢çš„ç”¨æˆ· |
| **Knowt** | Web/iOS/Android | å…è´¹ã€AIè¾…åŠ©ç”Ÿæˆå¡ç‰‡ | é¢„ç®—æœ‰é™çš„ç”¨æˆ· |

### 4.2 ç®—æ³•ä¸ç†è®ºèµ„æº

**å­¦æœ¯è®ºæ–‡**ï¼š
- Piotr Wozniak - *The SuperMemo method* (1990)
- Cepeda, N. J. et al. - *Distributed practice in verbal recall tasks* (2006)
- Lindsey, R. V. et al. - *Improving students' long-term knowledge retention* (2014)

**åœ¨çº¿èµ„æº**ï¼š
- SuperMemo.guru - é—´éš”é‡å¤ç›¸å…³çŸ¥è¯†çš„æƒå¨ç™¾ç§‘
- Anki Manual - Ankiå®˜æ–¹æ–‡æ¡£ä¸­çš„ç®—æ³•è¯´æ˜
- Quantum Computing for Computer Scientists - ä½¿ç”¨é—´éš”é‡å¤å­¦ä¹ å¤æ‚æŠ€æœ¯ä¹¦ç±çš„ç¤ºä¾‹

### 4.3 å¼€æºé¡¹ç›®

| é¡¹ç›®åç§° | æŠ€æœ¯æ ˆ | æè¿° |
|----------|--------|------|
| **Anki** | Python/Rust | æœ€æµè¡Œçš„å¼€æºé—´éš”é‡å¤è½¯ä»¶ |
| **Mnemosyne** | Python | è·¨å¹³å°è®°å¿†å¡è½¯ä»¶ |
| **org-drill** | Emacs Lisp | Emacs Org-modeçš„é—´éš”é‡å¤æ‰©å±• |
| **srs-rs** | Rust | Rustå®ç°çš„é—´éš”é‡å¤ç®—æ³•åº“ |
| **fsrs4anki** | Python/TS | FSRSç®—æ³•çš„Ankiå®ç° |

---

## 5. å…³è”çŸ¥è¯†

### 5.1 ä¸Šæ¸¸çŸ¥è¯†

```
C01_Spaced_Repetition
â”œâ”€â”€ A06_Technical_Intuition/B01_CS_Theories/C01_Complexity_Analysis
â”‚   â””â”€â”€ ç®—æ³•å¤æ‚åº¦åˆ†æ - ç†è§£è°ƒåº¦ç®—æ³•çš„æ—¶é—´å’Œç©ºé—´å¤æ‚åº¦
â”œâ”€â”€ A07_Knowledge_Ops/B02_Content_Strategy/C01_Atomic_Notes
â”‚   â””â”€â”€ åŸå­ç¬”è®° - é—´éš”é‡å¤å¡ç‰‡çš„å†…å®¹æ¥æº
â””â”€â”€ A07_Knowledge_Ops/B02_Content_Strategy/C02_Cross-Linking
    â””â”€â”€ äº¤å‰é“¾æ¥ - å»ºç«‹å¡ç‰‡é—´çš„çŸ¥è¯†è¿æ¥
```

### 5.2 ä¸‹æ¸¸åº”ç”¨

```
C01_Spaced_Repetition
â”œâ”€â”€ A02_Programming_Languages/B01_Python/C01_Core_Syntax
â”‚   â””â”€â”€ Pythonè¯­æ³•å¡ç‰‡åº“
â”œâ”€â”€ A04_Data_AI/B01_Machine_Learning/C01_Supervised_Learning
â”‚   â””â”€â”€ MLæ¦‚å¿µè®°å¿†
â””â”€â”€ A05_Security_Infra/B01_Cybersecurity/C01_Cryptography_Basics
    â””â”€â”€ å¯†ç å­¦æ¦‚å¿µè®°å¿†
```

### 5.3 æ¨ªå‘å…³è”

- **ä¸»åŠ¨å›å¿†ï¼ˆActive Recallï¼‰**ï¼šé—´éš”é‡å¤çš„æ ¸å¿ƒæœºåˆ¶ï¼Œå¼ºè°ƒä»è®°å¿†ä¸­æå–ä¿¡æ¯
- **äº¤é”™å­¦ä¹ ï¼ˆInterleavingï¼‰**ï¼šä¸é—´éš”é‡å¤é…åˆä½¿ç”¨ï¼Œæ··åˆä¸åŒç±»å‹é—®é¢˜çš„å­¦ä¹ 
- **ç²¾ç»†ç¼–ç ï¼ˆElaborative Encodingï¼‰**ï¼šæé«˜å¡ç‰‡è´¨é‡å’Œè®°å¿†æ·±åº¦
- **å…ƒè®¤çŸ¥ç›‘æ§ï¼ˆMetacognitive Monitoringï¼‰**ï¼šå­¦ä¹ è€…å¯¹è‡ªèº«å­¦ä¹ çŠ¶æ€çš„è§‰å¯Ÿ

---

## 6. å­¦ä¹ å»ºè®®

### 6.1 åˆå­¦è€…è·¯å¾„ï¼ˆç¬¬1-2å‘¨ï¼‰

**ç›®æ ‡**ï¼šå»ºç«‹åŸºæœ¬çš„é—´éš”é‡å¤ä¹ æƒ¯å’Œå·¥å…·ä½¿ç”¨èƒ½åŠ›

1. **ç¬¬1å¤©**ï¼šå®‰è£…Ankiï¼Œå®ŒæˆåŸºç¡€è®¾ç½®
2. **ç¬¬2-3å¤©**ï¼šå­¦ä¹ å¡ç‰‡åˆ¶ä½œåŸºç¡€ï¼Œåˆ›å»ºç¬¬ä¸€æ‰¹10-20å¼ å¡ç‰‡
3. **ç¬¬4-7å¤©**ï¼šæ¯å¤©å®Œæˆæ‰€æœ‰åˆ°æœŸå¤ä¹ ï¼Œä½“éªŒå¤ä¹ æµç¨‹
4. **ç¬¬2å‘¨**ï¼šå­¦ä¹ é«˜çº§å¡ç‰‡æ¨¡æ¿ï¼ˆå¡«ç©ºé¢˜ã€è¾“å…¥é¢˜ï¼‰ï¼Œæ¯æ—¥æ–°å¡æ§åˆ¶åœ¨10-20å¼ 

**å…³é”®æç¤º**ï¼š
- å‰ä¸¤å‘¨é‡ç‚¹ä¸æ˜¯å­¦ä¹ å¤§é‡å†…å®¹ï¼Œè€Œæ˜¯å»ºç«‹ç¨³å®šçš„ä¹ æƒ¯
- ä¸è¦è·³è¿‡ä»»ä½•ä¸€å¤©çš„å¤ä¹ 
- å¦‚æœå‘ç°æŸå¤©å¤ä¹ é‡è¿‡å¤§ï¼Œå‡å°‘æ–°å¡æ•°é‡

### 6.2 è¿›é˜¶è·¯å¾„ï¼ˆç¬¬3-8å‘¨ï¼‰

**ç›®æ ‡**ï¼šæŒæ¡é«˜çº§åŠŸèƒ½ï¼Œå»ºç«‹ä¸ªäººçŸ¥è¯†åº“

1. **å­¦ä¹ æ’ä»¶ç³»ç»Ÿ**ï¼šå®‰è£…Essential Anatomyã€Review Heatmapç­‰æœ‰ç”¨æ’ä»¶
2. **ä¼˜åŒ–å¡ç‰‡è®¾è®¡**ï¼šå­¦ä¹ Cloze Deletionã€å›¾ç‰‡é®æŒ¡å¡ç­‰é«˜çº§æŠ€å·§
3. **å»ºç«‹åˆ†ç±»ä½“ç³»**ï¼šä½¿ç”¨æ ‡ç­¾å’Œç‰Œç»„ç»„ç»‡ä¸åŒé¢†åŸŸçš„çŸ¥è¯†
4. **æ•°æ®åŒæ­¥**ï¼šè®¾ç½®AnkiWebæˆ–è‡ªå»ºåŒæ­¥æœåŠ¡å™¨

**é‡Œç¨‹ç¢‘æ£€æŸ¥ç‚¹**ï¼š
- ç¬¬4å‘¨æœ«ï¼šå¡ç‰‡åº“è¾¾åˆ°200å¼ 
- ç¬¬6å‘¨æœ«ï¼šæŒæ¡è‡³å°‘5ç§å¡ç‰‡ç±»å‹
- ç¬¬8å‘¨æœ«ï¼šæ—¥å‡å¤ä¹ æ—¶é—´ç¨³å®šåœ¨30åˆ†é’Ÿå†…

### 6.3 ä¸“å®¶å®è·µï¼ˆç¬¬9å‘¨+ï¼‰

**ç›®æ ‡**ï¼šå°†é—´éš”é‡å¤èå…¥å·¥ä½œæµï¼Œå®ç°çŸ¥è¯†å¤åˆ©

1. **è‡ªåŠ¨åŒ–é›†æˆ**ï¼š
   - æµè§ˆå™¨æ’ä»¶è‡ªåŠ¨åˆ¶å¡
   - Kindleæ ‡æ³¨è‡ªåŠ¨å¯¼å…¥
   - RSSé˜…è¯»å™¨æ–‡ç« è½¬å¡ç‰‡

2. **ç®—æ³•è°ƒä¼˜**ï¼š
   - äº†è§£FSRSç®—æ³•å‚æ•°
   - æ ¹æ®ä¸ªäººè®°å¿†ç‰¹ç‚¹è°ƒæ•´æœŸæœ›ä¿ç•™ç‡
   - åˆ†æä¸ªäººå­¦ä¹ æ•°æ®è¿›è¡Œä¼˜åŒ–

3. **çŸ¥è¯†å›¾è°±æ„å»º**ï¼š
   - ç»“åˆæ¦‚å¿µå›¾è°±å¯è§†åŒ–çŸ¥è¯†è¿æ¥
   - è¯†åˆ«çŸ¥è¯†ç¼ºå£å’Œè–„å¼±ç¯èŠ‚
   - æˆ˜ç•¥æ€§è¡¥å……ç›¸å…³å¡ç‰‡

### 6.4 å¸¸è§é™·é˜±ä¸é¿å…ç­–ç•¥

| é™·é˜± | ç—‡çŠ¶ | è§£å†³æ–¹æ¡ˆ |
|------|------|----------|
| **å¡ç‰‡è¿‡å¤š** | æ¯å¤©å¤ä¹ è¶…è¿‡1å°æ—¶ï¼Œæ„Ÿåˆ°å‹åŠ› | æš‚åœæ–°å¡ï¼Œä½¿ç”¨"é—å¿˜"é€‰é¡¹å¿«é€Ÿæ¸…ç† |
| **å¡ç‰‡è´¨é‡å·®** | é¢‘ç¹åœ¨"å›°éš¾"å’Œ"å¿˜è®°"é—´æ‘‡æ‘† | é‡æ–°è®¾è®¡å¡ç‰‡ï¼Œéµå¾ªåŸå­æ€§åŸåˆ™ |
| **å®Œç¾ä¸»ä¹‰** | èŠ±å¤ªå¤šæ—¶é—´åˆ¶ä½œå¡ç‰‡ï¼Œå­¦ä¹ æ—¶é—´å°‘ | éµå¾ª"åˆ¶ä½œä¸€å¼ å¡ç‰‡ä¸è¶…è¿‡1åˆ†é’Ÿ"åŸåˆ™ |
| **ä¸Šä¸‹æ–‡ç¼ºå¤±** | è®°å¾—ç­”æ¡ˆä½†ä¸ç†è§£å«ä¹‰ | æ·»åŠ æ›´å¤šä¸Šä¸‹æ–‡ä¿¡æ¯åˆ°å¡ç‰‡ |
| **åŠ¨æœºä¸‹é™** | è¿ç»­å‡ å¤©è·³è¿‡å¤ä¹  | å‡å°‘æ–°å¡æ•°é‡ï¼Œä½¿ç”¨æ’ä»¶å¢åŠ è¶£å‘³æ€§ |

### 6.5 æ¨èé˜…è¯»æ¸…å•

**å…¥é—¨**ï¼š
1. ã€ŠMake It Stickã€‹ - Peter C. Brownï¼ˆé—´éš”æ•ˆåº”çš„é€šä¿—è§£é‡Šï¼‰
2. Ankiå®˜æ–¹æ–‡æ¡£ - å®Œæ•´é˜…è¯»ä¸€é

**è¿›é˜¶**ï¼š
1. Piotr Wozniakçš„æ–‡ç«  - é—´éš”é‡å¤çš„ç§‘å­¦åŸºç¡€
2. ã€Šå¦‚ä½•å­¦ä¹ ã€‹ï¼ˆA Mind for Numbersï¼‰- Barbara Oakley

**ä¸“ä¸š**ï¼š
1. SuperMemo.guruä¸Šçš„æŠ€æœ¯æ–‡ç« 
2. è®¤çŸ¥å¿ƒç†å­¦æ•™ç§‘ä¹¦ä¸­çš„è®°å¿†ç« èŠ‚

---

## é™„å½•ï¼šå¿«é€Ÿå‚è€ƒå¡ç‰‡

### SM-2ç®—æ³•é€ŸæŸ¥

```
è¯„åˆ†æ ‡å‡†ï¼š
5 - å®Œç¾å›å¿†
4 - ç¨æœ‰çŠ¹è±«
3 - æœ‰å›°éš¾
2 - æç¤ºåæ­£ç¡®
1 - çœ‹èµ·æ¥ç†Ÿæ‚‰
0 - å®Œå…¨é—å¿˜

é—´éš”è®¡ç®—ï¼š
- ç¬¬1æ¬¡æˆåŠŸï¼š1å¤©
- ç¬¬2æ¬¡æˆåŠŸï¼š6å¤©  
- ç¬¬næ¬¡æˆåŠŸï¼šinterval(n-1) Ã— EF

EFæ›´æ–°ï¼š
EF' = EF + (0.1 - (5-Q) Ã— (0.08 + (5-Q) Ã— 0.02))
```

### å¡ç‰‡è®¾è®¡æ£€æŸ¥æ¸…å•

- [ ] ä¸€ä¸ªé—®é¢˜ä¸€ä¸ªç­”æ¡ˆï¼ˆåŸå­æ€§ï¼‰
- [ ] é—®é¢˜è¡¨è¿°æ¸…æ™°æ— æ­§ä¹‰
- [ ] ç­”æ¡ˆå®Œæ•´ä½†ç®€æ´
- [ ] æ·»åŠ äº†ç›¸å…³ä¸Šä¸‹æ–‡
- [ ] ä½¿ç”¨äº†é€‚å½“çš„æ ¼å¼ï¼ˆç²—ä½“ã€ä»£ç å—ç­‰ï¼‰
- [ ] åŒ…å«ç›¸å…³æ ‡ç­¾
- [ ] å›¾ç‰‡/å›¾è¡¨æœ‰åŠ©äºç†è§£ï¼ˆå¦‚é€‚ç”¨ï¼‰

---

*æœ€åæ›´æ–°ï¼š2026-01-30*
*ç»´æŠ¤è€…ï¼šZCO Knowledge Ops Team*

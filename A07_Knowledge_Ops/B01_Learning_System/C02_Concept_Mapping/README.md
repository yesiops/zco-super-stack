# C02_Concept_Mapping - æ¦‚å¿µå›¾è°±

> æ„å»ºå¯è§†åŒ–çŸ¥è¯†ç»“æ„ä¸æ¦‚å¿µé—´å…³ç³»çš„è®¤çŸ¥å·¥å…·

---

## 1. ä¸»é¢˜å®šä½

### 1.1 å®šä¹‰ä¸èƒŒæ™¯

æ¦‚å¿µå›¾è°±ï¼ˆConcept Mappingï¼‰æ˜¯ä¸€ç§ä»¥å›¾å½¢åŒ–æ–¹å¼ç»„ç»‡å’Œè¡¨ç¤ºçŸ¥è¯†çš„è®¤çŸ¥å·¥å…·ï¼Œç”±åº·å¥ˆå°”å¤§å­¦çš„Joseph D. NovakåŠå…¶ç ”ç©¶å›¢é˜Ÿäº1970å¹´ä»£åœ¨David Ausubelçš„æ„ä¹‰å­¦ä¹ ç†è®ºåŸºç¡€ä¸Šå¼€å‘ã€‚æ¦‚å¿µå›¾è°±é€šè¿‡èŠ‚ç‚¹ï¼ˆæ¦‚å¿µï¼‰å’Œè¿çº¿ï¼ˆå…³ç³»ï¼‰çš„æ–¹å¼ï¼Œå°†æŠ½è±¡çš„çŸ¥è¯†ç»“æ„è½¬åŒ–ä¸ºå¯è§†åŒ–çš„ç½‘ç»œå½¢å¼ï¼Œå¸®åŠ©å­¦ä¹ è€…ç†è§£æ¦‚å¿µé—´çš„å±‚æ¬¡å…³ç³»å’Œè¯­ä¹‰è¿æ¥ã€‚

ä¸æ€ç»´å¯¼å›¾ï¼ˆMind Mapï¼‰ä¸åŒï¼Œæ¦‚å¿µå›¾è°±å¼ºè°ƒæ¦‚å¿µé—´çš„**å‘½é¢˜å…³ç³»**ï¼ˆPropositional Relationshipsï¼‰ï¼Œå³é€šè¿‡è¿æ¥è¯ï¼ˆLinking Wordsï¼‰æ˜ç¡®è¡¨è¾¾ä¸¤ä¸ªæ¦‚å¿µä¹‹é—´çš„è¯­ä¹‰å…³ç³»ã€‚è¿™ç§ç»“æ„æ›´ç¬¦åˆäººç±»è®¤çŸ¥ç³»ç»Ÿä¸­å¯¹çŸ¥è¯†çš„å­˜å‚¨å’Œæ£€ç´¢æ–¹å¼ã€‚

### 1.2 æ ¸å¿ƒç‰¹å¾

| ç‰¹å¾ç»´åº¦ | æè¿° |
|----------|------|
| **å±‚çº§ç»“æ„** | ä»æœ€ä¸€èˆ¬ã€æœ€åŒ…å®¹çš„æ¦‚å¿µåˆ°æœ€å…·ä½“ã€æœ€ç‰¹æ®Šçš„æ¦‚å¿µ |
| **äº¤å‰è¿æ¥** | ä¸åŒåˆ†æ”¯æ¦‚å¿µé—´çš„æ¨ªå‘å…³è”ï¼Œä½“ç°çŸ¥è¯†çš„æ•´åˆæ€§ |
| **å‘½é¢˜ç»“æ„** | æ¦‚å¿µ-è¿æ¥è¯-æ¦‚å¿µçš„ä¸‰å…ƒç»„æ„æˆæœ‰æ„ä¹‰çš„é™ˆè¿° |
| **ç„¦ç‚¹é—®é¢˜** | å›´ç»•ä¸€ä¸ªæ ¸å¿ƒé—®é¢˜æˆ–ä¸»é¢˜å±•å¼€æ•´ä¸ªå›¾è°± |

### 1.3 åº”ç”¨åœºæ™¯

- **æ•™å­¦è®¾è®¡**ï¼šå¸®åŠ©æ•™å¸ˆç»„ç»‡è¯¾ç¨‹å†…å®¹ï¼Œè¯†åˆ«å­¦ç”Ÿçš„å…ˆéªŒçŸ¥è¯†
- **çŸ¥è¯†è¯„ä¼°**ï¼šé€šè¿‡åˆ†æå­¦ä¹ è€…æ„å»ºçš„æ¦‚å¿µå›¾è°±è¯„ä¼°ç†è§£æ·±åº¦
- **çŸ¥è¯†æ•´åˆ**ï¼šå°†æ–°çŸ¥è¯†ä¸å·²æœ‰çŸ¥è¯†æ¡†æ¶è¿æ¥
- **åä½œå­¦ä¹ **ï¼šå›¢é˜Ÿæˆå‘˜å…±åŒæ„å»ºå…±äº«çŸ¥è¯†æ¨¡å‹
- **å¤æ‚ç³»ç»Ÿåˆ†æ**ï¼šç†è§£è½¯ä»¶æ¶æ„ã€ä¸šåŠ¡æµç¨‹ç­‰å¤æ‚ç³»ç»Ÿ

---

## 2. æ ¸å¿ƒæ¦‚å¿µ

### 2.1 ç†è®ºåŸºç¡€ï¼šæ„ä¹‰å­¦ä¹ 

David Ausubelçš„æ„ä¹‰å­¦ä¹ ç†è®ºï¼ˆMeaningful Learning Theoryï¼‰æ˜¯æ¦‚å¿µå›¾è°±çš„ç†è®ºåŸºçŸ³ã€‚è¯¥ç†è®ºè®¤ä¸ºï¼š

```
æ„ä¹‰å­¦ä¹ çš„æ¡ä»¶ï¼š
1. å­¦ä¹ ææ–™æœ¬èº«å…·æœ‰é€»è¾‘æ„ä¹‰
2. å­¦ä¹ è€…å…·æœ‰ç›¸å…³çš„å…ˆéªŒçŸ¥è¯†
3. å­¦ä¹ è€…å…·æœ‰æ„ä¹‰å­¦ä¹ çš„å¿ƒå‘ï¼ˆéæœºæ¢°è®°å¿†ï¼‰

å…³é”®æœºåˆ¶ï¼š
- é™„å±å­¦ä¹ ï¼ˆSubsumptionï¼‰ï¼šæ–°çŸ¥è¯†å½’å±äºå·²æœ‰è®¤çŸ¥ç»“æ„ä¸­
- æ€»æ‹¬å­¦ä¹ ï¼ˆSuperordinate Learningï¼‰ï¼šå·²æœ‰çŸ¥è¯†å½’å±äºæ›´ä¸€èˆ¬çš„æ¦‚å¿µ
- ç»„åˆå­¦ä¹ ï¼ˆCombinatorial Learningï¼‰ï¼šæ–°çŸ¥è¯†ä¸å·²æœ‰çŸ¥è¯†å¹¶åˆ—ç»“åˆ
```

### 2.2 æ¦‚å¿µå›¾è°±è¦ç´ 

#### 2.2.1 æ¦‚å¿µï¼ˆConceptsï¼‰

æ¦‚å¿µæ˜¯æ„ŸçŸ¥åˆ°çš„è§„å¾‹æ€§æˆ–äº‹ä»¶ï¼Œä»¥ç¬¦å·ï¼ˆé€šå¸¸æ˜¯è¯æ±‡ï¼‰æ ‡è®°ï¼š

```
æ¦‚å¿µåˆ†ç±»ï¼š
â”œâ”€ å…·ä½“æ¦‚å¿µï¼šå¯ç›´æ¥æ„ŸçŸ¥çš„å¯¹è±¡ï¼ˆå¦‚ï¼šæœåŠ¡å™¨ã€æ•°æ®åº“ï¼‰
â”œâ”€ æŠ½è±¡æ¦‚å¿µï¼šéœ€è¦æŠ½è±¡æ€ç»´ï¼ˆå¦‚ï¼šå¹¶å‘ã€è§£è€¦ï¼‰
â”œâ”€ è¿‡ç¨‹æ¦‚å¿µï¼šæè¿°æ“ä½œæˆ–æµç¨‹ï¼ˆå¦‚ï¼šè´Ÿè½½å‡è¡¡ã€æ•…éšœè½¬ç§»ï¼‰
â””â”€ å…ƒæ¦‚å¿µï¼šå…³äºçŸ¥è¯†çš„æ¦‚å¿µï¼ˆå¦‚ï¼šè®¾è®¡æ¨¡å¼ã€æ¶æ„é£æ ¼ï¼‰
```

#### 2.2.2 å…³ç³»è¿æ¥ï¼ˆLinking Words/Phrasesï¼‰

è¿æ¥è¯å®šä¹‰äº†æ¦‚å¿µé—´çš„å…³ç³»ç±»å‹ï¼š

| å…³ç³»ç±»å‹ | è¿æ¥è¯ç¤ºä¾‹ | ç¤ºä¾‹å‘½é¢˜ |
|----------|------------|----------|
| **åŒ…å«** | åŒ…å«ã€ç”±...ç»„æˆã€æœ‰ | å¾®æœåŠ¡æ¶æ„åŒ…å«æœåŠ¡å‘ç° |
| **å¯¼è‡´** | å¯¼è‡´ã€äº§ç”Ÿã€å¼•èµ· | é«˜å¹¶å‘å¯¼è‡´èµ„æºç«äº‰ |
| **å±æ€§** | å…·æœ‰ã€ç‰¹å¾ä¸º | åˆ†å¸ƒå¼ç³»ç»Ÿå…·æœ‰CAPç‰¹æ€§ |
| **ç¤ºä¾‹** | ä¾‹å¦‚ã€å¦‚ã€å®ä¾‹ | æ¶ˆæ¯é˜Ÿåˆ—å¦‚Kafka |
| **ä¾èµ–** | ä¾èµ–ã€éœ€è¦ã€åŸºäº | ç¼“å­˜ç­–ç•¥ä¾èµ–äºè®¿é—®æ¨¡å¼ |
| **å¯¹æ¯”** | ä¸åŒäºã€ç›¸æ¯”ã€è€Œé | RESTä¸åŒäºRPC |

#### 2.2.3 å±‚çº§ç»“æ„

æ¦‚å¿µå›¾è°±é‡‡ç”¨ä»ä¸Šåˆ°ä¸‹çš„å±‚çº§ç»„ç»‡ï¼š

```
                    [æœ€ä¸€èˆ¬æ¦‚å¿µ]
                          â”‚
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â–¼             â–¼             â–¼
       [å­æ¦‚å¿µA]     [å­æ¦‚å¿µB]     [å­æ¦‚å¿µC]
            â”‚             â”‚             â”‚
      â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”´â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”
      â–¼           â–¼   â–¼       â–¼   â–¼           â–¼
   [å…·ä½“A1]   [å…·ä½“A2] [B1]  [B2] [C1]     [å…·ä½“C2]
   
å±‚çº§åŸåˆ™ï¼š
- ä¸Šå±‚æ¦‚å¿µåŒ…å«ä¸‹å±‚æ¦‚å¿µ
- åŒä¸€å±‚çº§æ¦‚å¿µå…·æœ‰ç›¸ä¼¼çš„ä¸€èˆ¬æ€§ç¨‹åº¦
- é¿å…è·¨å±‚çº§ç›´æ¥è¿æ¥
```

#### 2.2.4 äº¤å‰è¿æ¥ï¼ˆCross Linksï¼‰

äº¤å‰è¿æ¥æ˜¯ä¸åŒåˆ†æ”¯æ¦‚å¿µé—´çš„å…³ç³»ï¼Œæ˜¯æ¦‚å¿µå›¾è°±çš„é‡è¦ç‰¹å¾ï¼š

```
        [åˆ†å¸ƒå¼ç³»ç»Ÿ]                          [æ•°æ®åº“ç³»ç»Ÿ]
              â”‚                                    â”‚
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â–¼               â–¼                  â–¼                   â–¼
  [ä¸€è‡´æ€§æ¨¡å‹]    [åˆ†åŒºå®¹é”™]          [ACID]             [BASE]
      â”‚               â”‚                  â”‚                   â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â”‚
                      â”‚                                      â”‚
                      â–¼                                      â–¼
              [CAPå®šç†] â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ [æœ€ç»ˆä¸€è‡´æ€§]
              
äº¤å‰è¿æ¥æ­ç¤ºï¼š
- ä¸åŒé¢†åŸŸæ¦‚å¿µé—´çš„æ·±å±‚è”ç³»
- çŸ¥è¯†æ•´åˆå’Œåˆ›æ–°æ€ç»´çš„åŸºç¡€
- é«˜çº§è®¤çŸ¥èƒ½åŠ›çš„æ ‡å¿—
```

### 2.3 æ¦‚å¿µå›¾è°±ç±»å‹

#### 2.3.1 èœ˜è››å‹ï¼ˆSpoke/Radialï¼‰

```
              [ä¸­å¿ƒæ¦‚å¿µ]
            /    â”‚    \
          /      â”‚      \
   [æ¦‚å¿µA]  [æ¦‚å¿µB]  [æ¦‚å¿µC]  [æ¦‚å¿µD]
        \        â”‚        /
         \       â”‚       /
          \      â”‚      /
           \     â”‚     /
            \    â”‚    /
             \   â”‚   /
              \  â”‚  /
               \ â”‚ /
            [æ•´åˆæ¦‚å¿µ]

é€‚ç”¨åœºæ™¯ï¼šä¸­å¿ƒè¾å°„å¼çŸ¥è¯†ï¼Œå¦‚æŠ€æœ¯é€‰å‹æ¯”è¾ƒ
```

#### 2.3.2 å±‚çº§å‹ï¼ˆHierarchicalï¼‰

```
                    [æ ¹æ¦‚å¿µ]
                   /   |   \
                  /    |    \
              [L1-A] [L1-B] [L1-C]
                / \      |      \
               /   \     |       \
           [L2-A1][L2-A2][L2-B1] [L2-C1]
            /         \    |        \
        [L3-A1a]  [L3-A2a] ...    ...

é€‚ç”¨åœºæ™¯ï¼šåˆ†ç±»ä½“ç³»ã€æ¶æ„å±‚æ¬¡ã€ç»§æ‰¿å…³ç³»
```

#### 2.3.3 æµç¨‹å‹ï¼ˆFlow/Chainï¼‰

```
[è¾“å…¥] â”€â”€â†’ [å¤„ç†1] â”€â”€â†’ [å¤„ç†2] â”€â”€â†’ [å¤„ç†3] â”€â”€â†’ [è¾“å‡º]
            â”‚           â”‚           â”‚
            â–¼           â–¼           â–¼
        [åé¦ˆ1]     [ç›‘æ§]      [ä¼˜åŒ–]
            â”‚           â”‚           â”‚
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
                        â–¼
                   [å›ç¯åˆ°è¾“å…¥]

é€‚ç”¨åœºæ™¯ï¼šç®—æ³•æµç¨‹ã€ç³»ç»Ÿäº¤äº’ã€çŠ¶æ€è½¬æ¢
```

#### 2.3.4 ç³»ç»Ÿå‹ï¼ˆSystemï¼‰

```
           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
           â”‚           [ç³»ç»Ÿè¾¹ç•Œ]                  â”‚
           â”‚                                      â”‚
    [å¤–éƒ¨å®ä½“A] â†â”€â”€â”€â†’ [æ ¸å¿ƒç»„ä»¶] â†â”€â”€â”€â†’ [å¤–éƒ¨å®ä½“B]
           â”‚              â”‚                â”‚
           â”‚         â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”           â”‚
           â”‚         â–¼         â–¼           â”‚
           â”‚    [å­ç³»ç»ŸX]  [å­ç³»ç»ŸY]        â”‚
           â”‚         â”‚         â”‚            â”‚
           â”‚         â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜            â”‚
           â”‚              â”‚                 â”‚
           â”‚              â–¼                 â”‚
           â”‚         [å…±äº«èµ„æº]              â”‚
           â”‚                              â”‚
           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

é€‚ç”¨åœºæ™¯ï¼šç³»ç»Ÿæ¶æ„ã€ç”Ÿæ€åˆ†æã€å¤æ‚äº¤äº’
```

---

## 3. æŠ€æœ¯å®è·µ

### 3.1 æ¦‚å¿µå›¾è°±æ„å»ºæµç¨‹

#### 3.1.1 ç³»ç»ŸåŒ–æ„å»ºæ­¥éª¤

```python
from enum import Enum, auto
from dataclasses import dataclass, field
from typing import List, Dict, Set, Optional, Tuple
import json
import uuid

class RelationType(Enum):
    """å…³ç³»ç±»å‹æšä¸¾"""
    IS_A = auto()              # æ˜¯ä¸€ç§
    PART_OF = auto()           # æ˜¯...çš„ä¸€éƒ¨åˆ†
    HAS = auto()               # å…·æœ‰
    LEADS_TO = auto()          # å¯¼è‡´
    DEPENDS_ON = auto()        # ä¾èµ–äº
    EXAMPLE_OF = auto()        # æ˜¯...çš„ä¾‹å­
    CONTRASTS_WITH = auto()    # ä¸...å¯¹æ¯”
    INFLUENCES = auto()        # å½±å“
    ENABLES = auto()           # ä½¿èƒ½
    PREVENTS = auto()          # é˜»æ­¢

RELATION_PHRASES = {
    RelationType.IS_A: ["æ˜¯ä¸€ç§", "æ˜¯", "å±äº"],
    RelationType.PART_OF: ["æ˜¯...çš„ä¸€éƒ¨åˆ†", "ç»„æˆ", "åŒ…å«äº"],
    RelationType.HAS: ["å…·æœ‰", "æ‹¥æœ‰", "ç‰¹å¾ä¸º"],
    RelationType.LEADS_TO: ["å¯¼è‡´", "äº§ç”Ÿ", "å¼•èµ·", "é€ æˆ"],
    RelationType.DEPENDS_ON: ["ä¾èµ–äº", "éœ€è¦", "åŸºäº"],
    RelationType.EXAMPLE_OF: ["æ˜¯...çš„ä¾‹å­", "ä¾‹å¦‚", "å¦‚"],
    RelationType.CONTRASTS_WITH: ["ä¸...å¯¹æ¯”", "ä¸åŒäº", "è€Œé"],
    RelationType.INFLUENCES: ["å½±å“", "ä½œç”¨äº", "æ”¹å˜"],
    RelationType.ENABLES: ["ä½¿èƒ½", "å…è®¸", "æ”¯æŒ"],
    RelationType.PREVENTS: ["é˜»æ­¢", "é˜²æ­¢", "é¿å…"]
}

@dataclass
class Concept:
    """æ¦‚å¿µèŠ‚ç‚¹"""
    id: str
    label: str
    description: str = ""
    category: str = "general"  # æ¦‚å¿µç±»åˆ«
    level: int = 0  # å±‚çº§ï¼ˆ0ä¸ºæœ€é«˜å±‚ï¼‰
    examples: List[str] = field(default_factory=list)
    tags: List[str] = field(default_factory=list)
    
    def __post_init__(self):
        if not self.id:
            self.id = str(uuid.uuid4())[:8]

@dataclass
class Proposition:
    """å‘½é¢˜ï¼šæ¦‚å¿µä¹‹é—´çš„å…³ç³»"""
    id: str
    source_id: str
    target_id: str
    relation_type: RelationType
    linking_phrase: str
    bidirectional: bool = False
    
    def __post_init__(self):
        if not self.id:
            self.id = str(uuid.uuid4())[:8]
    
    def to_statement(self, concepts: Dict[str, Concept]) -> str:
        """è½¬æ¢ä¸ºè‡ªç„¶è¯­è¨€é™ˆè¿°"""
        source = concepts.get(self.source_id, Concept("", "?")).label
        target = concepts.get(self.target_id, Concept("", "?")).label
        return f"{source} {self.linking_phrase} {target}"

class ConceptMap:
    """æ¦‚å¿µå›¾è°±æ ¸å¿ƒç±»"""
    
    def __init__(self, title: str, focus_question: str = ""):
        self.id = str(uuid.uuid4())[:8]
        self.title = title
        self.focus_question = focus_question
        self.concepts: Dict[str, Concept] = {}
        self.propositions: Dict[str, Proposition] = {}
        self.root_concept_id: Optional[str] = None
        
    def add_concept(self, label: str, description: str = "", 
                    category: str = "general", level: int = None,
                    parent_id: str = None) -> Concept:
        """æ·»åŠ æ¦‚å¿µèŠ‚ç‚¹"""
        # è‡ªåŠ¨è®¡ç®—å±‚çº§
        if level is None and parent_id:
            parent = self.concepts.get(parent_id)
            if parent:
                level = parent.level + 1
            else:
                level = 0
        elif level is None:
            level = 0
            
        concept = Concept(
            id=str(uuid.uuid4())[:8],
            label=label,
            description=description,
            category=category,
            level=level
        )
        self.concepts[concept.id] = concept
        
        # è®¾ç½®æ ¹æ¦‚å¿µ
        if level == 0 and not self.root_concept_id:
            self.root_concept_id = concept.id
            
        return concept
    
    def add_proposition(self, source_id: str, target_id: str,
                       relation_type: RelationType = RelationType.IS_A,
                       linking_phrase: str = None,
                       bidirectional: bool = False) -> Proposition:
        """æ·»åŠ å‘½é¢˜ï¼ˆå…³ç³»ï¼‰"""
        if linking_phrase is None:
            linking_phrase = RELATION_PHRASES[relation_type][0]
            
        prop = Proposition(
            id=str(uuid.uuid4())[:8],
            source_id=source_id,
            target_id=target_id,
            relation_type=relation_type,
            linking_phrase=linking_phrase,
            bidirectional=bidirectional
        )
        self.propositions[prop.id] = prop
        return prop
    
    def get_concept_by_label(self, label: str) -> Optional[Concept]:
        """é€šè¿‡æ ‡ç­¾æŸ¥æ‰¾æ¦‚å¿µ"""
        for concept in self.concepts.values():
            if concept.label == label:
                return concept
        return None
    
    def get_children(self, concept_id: str) -> List[Concept]:
        """è·å–å­æ¦‚å¿µï¼ˆé€šè¿‡å…³ç³»è¿æ¥ï¼‰"""
        children = []
        for prop in self.propositions.values():
            if prop.source_id == concept_id:
                child = self.concepts.get(prop.target_id)
                if child:
                    children.append(child)
        return children
    
    def get_parents(self, concept_id: str) -> List[Concept]:
        """è·å–çˆ¶æ¦‚å¿µ"""
        parents = []
        for prop in self.propositions.values():
            if prop.target_id == concept_id:
                parent = self.concepts.get(prop.source_id)
                if parent:
                    parents.append(parent)
        return parents
    
    def find_cross_links(self) -> List[Proposition]:
        """æŸ¥æ‰¾äº¤å‰è¿æ¥ï¼ˆä¸åŒåˆ†æ”¯é—´çš„è¿æ¥ï¼‰"""
        cross_links = []
        
        # è·å–æ¯ä¸ªæ¦‚å¿µçš„å±‚çº§è·¯å¾„
        def get_path(concept_id: str, visited: Set[str] = None) -> List[str]:
            if visited is None:
                visited = set()
            if concept_id in visited:
                return []
            visited.add(concept_id)
            
            concept = self.concepts.get(concept_id)
            if not concept or concept.level == 0:
                return [concept_id]
            
            parents = self.get_parents(concept_id)
            if not parents:
                return [concept_id]
            
            # è¿”å›å±‚çº§æœ€é«˜çš„çˆ¶èŠ‚ç‚¹
            top_parent = min(parents, key=lambda x: x.level)
            return get_path(top_parent.id, visited) + [concept_id]
        
        for prop in self.propositions.values():
            source_path = get_path(prop.source_id)
            target_path = get_path(prop.target_id)
            
            # å¦‚æœé¡¶çº§ç¥–å…ˆä¸åŒï¼Œåˆ™æ˜¯äº¤å‰è¿æ¥
            if source_path and target_path and source_path[0] != target_path[0]:
                cross_links.append(prop)
        
        return cross_links
    
    def calculate_complexity(self) -> Dict[str, any]:
        """è®¡ç®—æ¦‚å¿µå›¾è°±å¤æ‚åº¦æŒ‡æ ‡"""
        n_concepts = len(self.concepts)
        n_propositions = len(self.propositions)
        
        # ç½‘ç»œå¯†åº¦
        max_possible_links = n_concepts * (n_concepts - 1) / 2 if n_concepts > 1 else 1
        density = n_propositions / max_possible_links if max_possible_links > 0 else 0
        
        # å¹³å‡åº¦æ•°
        degrees = {}
        for concept_id in self.concepts:
            degree = sum(1 for p in self.propositions.values() 
                        if p.source_id == concept_id or p.target_id == concept_id)
            degrees[concept_id] = degree
        avg_degree = sum(degrees.values()) / n_concepts if n_concepts > 0 else 0
        
        # å±‚çº§æ·±åº¦
        max_depth = max(c.level for c in self.concepts.values()) if self.concepts else 0
        
        # äº¤å‰è¿æ¥æ•°
        cross_links = len(self.find_cross_links())
        
        return {
            "concepts": n_concepts,
            "propositions": n_propositions,
            "density": round(density, 4),
            "avg_degree": round(avg_degree, 2),
            "max_depth": max_depth,
            "cross_links": cross_links,
            "hierarchy_ratio": 1 - (cross_links / n_propositions) if n_propositions > 0 else 0
        }
    
    def export_to_cmap(self, filepath: str):
        """å¯¼å‡ºä¸ºCmapToolsæ ¼å¼"""
        # CmapToolsä½¿ç”¨XMLæ ¼å¼
        import xml.etree.ElementTree as ET
        
        root = ET.Element("cmap")
        root.set("xmlns", "http://cmap.ihmc.us/xml/cmap/")
        
        # æ·»åŠ æ¦‚å¿µ
        concepts_elem = ET.SubElement(root, "concepts")
        for concept in self.concepts.values():
            c_elem = ET.SubElement(concepts_elem, "concept")
            c_elem.set("id", concept.id)
            c_elem.set("label", concept.label)
        
        # æ·»åŠ è¿æ¥
        connections = ET.SubElement(root, "connections")
        for prop in self.propositions.values():
            conn = ET.SubElement(connections, "connection")
            conn.set("id", prop.id)
            conn.set("from", prop.source_id)
            conn.set("to", prop.target_id)
            conn.set("label", prop.linking_phrase)
        
        tree = ET.ElementTree(root)
        tree.write(filepath, encoding='utf-8', xml_declaration=True)
    
    def export_to_json(self, filepath: str):
        """å¯¼å‡ºä¸ºJSONæ ¼å¼"""
        data = {
            "id": self.id,
            "title": self.title,
            "focus_question": self.focus_question,
            "concepts": [
                {
                    "id": c.id,
                    "label": c.label,
                    "description": c.description,
                    "category": c.category,
                    "level": c.level,
                    "examples": c.examples,
                    "tags": c.tags
                }
                for c in self.concepts.values()
            ],
            "propositions": [
                {
                    "id": p.id,
                    "source_id": p.source_id,
                    "target_id": p.target_id,
                    "relation_type": p.relation_type.name,
                    "linking_phrase": p.linking_phrase,
                    "bidirectional": p.bidirectional
                }
                for p in self.propositions.values()
            ],
            "root_concept_id": self.root_concept_id,
            "complexity": self.calculate_complexity()
        }
        
        with open(filepath, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)
    
    @classmethod
    def from_json(cls, filepath: str) -> 'ConceptMap':
        """ä»JSONåŠ è½½æ¦‚å¿µå›¾è°±"""
        with open(filepath, 'r', encoding='utf-8') as f:
            data = json.load(f)
        
        cmap = cls(data['title'], data.get('focus_question', ''))
        cmap.id = data['id']
        cmap.root_concept_id = data.get('root_concept_id')
        
        # åŠ è½½æ¦‚å¿µ
        for c_data in data['concepts']:
            concept = Concept(
                id=c_data['id'],
                label=c_data['label'],
                description=c_data.get('description', ''),
                category=c_data.get('category', 'general'),
                level=c_data.get('level', 0),
                examples=c_data.get('examples', []),
                tags=c_data.get('tags', [])
            )
            cmap.concepts[concept.id] = concept
        
        # åŠ è½½å‘½é¢˜
        for p_data in data['propositions']:
            prop = Proposition(
                id=p_data['id'],
                source_id=p_data['source_id'],
                target_id=p_data['target_id'],
                relation_type=RelationType[p_data['relation_type']],
                linking_phrase=p_data['linking_phrase'],
                bidirectional=p_data.get('bidirectional', False)
            )
            cmap.propositions[prop.id] = prop
        
        return cmap


# ç¤ºä¾‹ï¼šæ„å»º"å¾®æœåŠ¡æ¶æ„"æ¦‚å¿µå›¾è°±
def create_microservices_concept_map() -> ConceptMap:
    """åˆ›å»ºå¾®æœåŠ¡æ¶æ„æ¦‚å¿µå›¾è°±ç¤ºä¾‹"""
    
    cmap = ConceptMap(
        title="å¾®æœåŠ¡æ¶æ„",
        focus_question="å¾®æœåŠ¡æ¶æ„çš„æ ¸å¿ƒæ¦‚å¿µå’Œç»„ä»¶æ˜¯ä»€ä¹ˆï¼Ÿ"
    )
    
    # æ·»åŠ æ ¸å¿ƒæ¦‚å¿µ
    root = cmap.add_concept("å¾®æœåŠ¡æ¶æ„", "ä¸€ç§å°†åº”ç”¨æ„å»ºä¸ºå°å‹æœåŠ¡é›†åˆçš„æ¶æ„é£æ ¼", "architecture", 0)
    cmap.root_concept_id = root.id
    
    # ç¬¬ä¸€å±‚æ¦‚å¿µ
    service = cmap.add_concept("æœåŠ¡", "ç‹¬ç«‹éƒ¨ç½²çš„ä¸šåŠ¡åŠŸèƒ½å•å…ƒ", "component", 1, root.id)
    comm = cmap.add_concept("æœåŠ¡é€šä¿¡", "æœåŠ¡é—´äº¤äº’æœºåˆ¶", "mechanism", 1, root.id)
    data = cmap.add_concept("æ•°æ®ç®¡ç†", "åˆ†å¸ƒå¼æ•°æ®ç­–ç•¥", "mechanism", 1, root.id)
    governance = cmap.add_concept("æœåŠ¡æ²»ç†", "æœåŠ¡è¿è¡Œæ—¶çš„ç®¡ç†", "management", 1, root.id)
    
    # æ·»åŠ å…³ç³»
    cmap.add_proposition(root.id, service.id, RelationType.HAS, "åŒ…å«")
    cmap.add_proposition(root.id, comm.id, RelationType.REQUIRES, "éœ€è¦")
    cmap.add_proposition(root.id, data.id, RelationType.INVOLVES, "æ¶‰åŠ")
    cmap.add_proposition(root.id, governance.id, RelationType.NEEDS, "ä¾èµ–")
    
    # ç¬¬äºŒå±‚ï¼šæœåŠ¡ç‰¹æ€§
    independence = cmap.add_concept("ç‹¬ç«‹æ€§", "æœåŠ¡å¯ç‹¬ç«‹å¼€å‘éƒ¨ç½²", "characteristic", 2)
    bounded_ctx = cmap.add_concept("é™ç•Œä¸Šä¸‹æ–‡", "é¢†åŸŸè¾¹ç•Œåˆ’åˆ†", "pattern", 2)
    cmap.add_proposition(service.id, independence.id, RelationType.HAS, "å…·æœ‰")
    cmap.add_proposition(service.id, bounded_ctx.id, RelationType.IMPLEMENTS, "å®ç°")
    
    # ç¬¬äºŒå±‚ï¼šé€šä¿¡æ–¹å¼
    sync = cmap.add_concept("åŒæ­¥é€šä¿¡", "è¯·æ±‚-å“åº”æ¨¡å¼", "pattern", 2)
    async_comm = cmap.add_concept("å¼‚æ­¥é€šä¿¡", "æ¶ˆæ¯é©±åŠ¨æ¨¡å¼", "pattern", 2)
    cmap.add_proposition(comm.id, sync.id, RelationType.INCLUDES, "åŒ…æ‹¬")
    cmap.add_proposition(comm.id, async_comm.id, RelationType.INCLUDES, "åŒ…æ‹¬")
    
    # å…·ä½“æŠ€æœ¯ç¤ºä¾‹
    http = cmap.add_concept("HTTP/REST", "åŒæ­¥é€šä¿¡åè®®", "technology", 3)
    grpc = cmap.add_concept("gRPC", "é«˜æ€§èƒ½RPCæ¡†æ¶", "technology", 3)
    cmap.add_proposition(sync.id, http.id, RelationType.EXAMPLE_OF, "ä¾‹å¦‚")
    cmap.add_proposition(sync.id, grpc.id, RelationType.EXAMPLE_OF, "ä¾‹å¦‚")
    
    kafka = cmap.add_concept("Kafka", "åˆ†å¸ƒå¼æ¶ˆæ¯é˜Ÿåˆ—", "technology", 3)
    rabbitmq = cmap.add_concept("RabbitMQ", "æ¶ˆæ¯ä¸­é—´ä»¶", "technology", 3)
    cmap.add_proposition(async_comm.id, kafka.id, RelationType.EXAMPLE_OF, "ä¾‹å¦‚")
    cmap.add_proposition(async_comm.id, rabbitmq.id, RelationType.EXAMPLE_OF, "ä¾‹å¦‚")
    
    # æ•°æ®ç®¡ç†
    db_per_service = cmap.add_concept("æ¯æœåŠ¡æ•°æ®åº“", "æ•°æ®éš”ç¦»åŸåˆ™", "pattern", 2)
    sagas = cmap.add_concept("Sagaæ¨¡å¼", "åˆ†å¸ƒå¼äº‹åŠ¡å¤„ç†", "pattern", 2)
    cmap.add_proposition(data.id, db_per_service.id, RelationType.USES, "ä½¿ç”¨")
    cmap.add_proposition(data.id, sagas.id, RelationType.REQUIRES, "éœ€è¦")
    
    # æœåŠ¡æ²»ç†
    discovery = cmap.add_concept("æœåŠ¡å‘ç°", "åŠ¨æ€æœåŠ¡å®šä½", "mechanism", 2)
    config = cmap.add_concept("é…ç½®ä¸­å¿ƒ", "é›†ä¸­é…ç½®ç®¡ç†", "mechanism", 2)
    gateway = cmap.add_concept("APIç½‘å…³", "ç»Ÿä¸€å…¥å£", "component", 2)
    cmap.add_proposition(governance.id, discovery.id, RelationType.INCLUDES, "åŒ…æ‹¬")
    cmap.add_proposition(governance.id, config.id, RelationType.INCLUDES, "åŒ…æ‹¬")
    cmap.add_proposition(governance.id, gateway.id, RelationType.INCLUDES, "åŒ…æ‹¬")
    
    # äº¤å‰è¿æ¥ï¼šå‘ç°Sagaä¸å¼‚æ­¥é€šä¿¡çš„å…³ç³»
    cmap.add_proposition(sagas.id, async_comm.id, RelationType.DEPENDS_ON, "ä¾èµ–äº", bidirectional=True)
    
    # äº¤å‰è¿æ¥ï¼šAPIç½‘å…³ä¸åŒæ­¥é€šä¿¡
    cmap.add_proposition(gateway.id, sync.id, RelationType.USES, "ä½¿ç”¨")
    
    return cmap


# è¿è¡Œç¤ºä¾‹
if __name__ == "__main__":
    cmap = create_microservices_concept_map()
    
    print("=" * 60)
    print(f"æ¦‚å¿µå›¾è°±: {cmap.title}")
    print(f"ç„¦ç‚¹é—®é¢˜: {cmap.focus_question}")
    print("=" * 60)
    
    print("\nğŸ“Š å¤æ‚åº¦åˆ†æ:")
    complexity = cmap.calculate_complexity()
    for key, value in complexity.items():
        print(f"  {key}: {value}")
    
    print("\nğŸ”— äº¤å‰è¿æ¥:")
    for prop in cmap.find_cross_links():
        statement = prop.to_statement(cmap.concepts)
        print(f"  â€¢ {statement}")
    
    print("\nğŸ“ å¯¼å‡ºåˆ°JSON...")
    cmap.export_to_json("microservices_concept_map.json")
    print("å®Œæˆ!")
```

### 3.2 æ¦‚å¿µå›¾è°±å¯è§†åŒ–

```python
import networkx as nx
import matplotlib.pyplot as plt
from matplotlib.patches import FancyBboxPatch, FancyArrowPatch
import numpy as np

class ConceptMapVisualizer:
    """æ¦‚å¿µå›¾è°±å¯è§†åŒ–å·¥å…·"""
    
    def __init__(self, cmap: ConceptMap):
        self.cmap = cmap
        self.G = nx.DiGraph()
        self._build_graph()
    
    def _build_graph(self):
        """æ„å»ºNetworkXå›¾"""
        # æ·»åŠ èŠ‚ç‚¹
        for concept in self.cmap.concepts.values():
            self.G.add_node(
                concept.id,
                label=concept.label,
                level=concept.level,
                category=concept.category
            )
        
        # æ·»åŠ è¾¹
        for prop in self.cmap.propositions.values():
            self.G.add_edge(
                prop.source_id,
                prop.target_id,
                label=prop.linking_phrase,
                relation=prop.relation_type.name
            )
    
    def visualize(self, figsize=(16, 12), layout='hierarchical'):
        """
        å¯è§†åŒ–æ¦‚å¿µå›¾è°±
        
        å‚æ•°:
            figsize: å›¾åƒå¤§å°
            layout: å¸ƒå±€ç®—æ³• ('hierarchical', 'spring', 'kamada_kawai')
        """
        fig, ax = plt.subplots(figsize=figsize)
        
        # è®¡ç®—å¸ƒå±€
        if layout == 'hierarchical':
            pos = self._hierarchical_layout()
        elif layout == 'spring':
            pos = nx.spring_layout(self.G, k=2, iterations=50)
        else:
            pos = nx.kamada_kawai_layout(self.G)
        
        # æŒ‰å±‚çº§ç€è‰²
        level_colors = {
            0: '#FF6B6B',  # çº¢è‰² - æ ¹æ¦‚å¿µ
            1: '#4ECDC4',  # é’è‰² - ä¸€çº§æ¦‚å¿µ
            2: '#45B7D1',  # è“è‰² - äºŒçº§æ¦‚å¿µ
            3: '#96CEB4',  # ç»¿è‰² - ä¸‰çº§æ¦‚å¿µ
            4: '#FFEAA7',  # é»„è‰² - å››çº§æ¦‚å¿µ
        }
        
        node_colors = []
        for node in self.G.nodes():
            level = self.G.nodes[node].get('level', 0)
            color = level_colors.get(level, '#DDA0DD')
            node_colors.append(color)
        
        # ç»˜åˆ¶èŠ‚ç‚¹
        nx.draw_networkx_nodes(
            self.G, pos,
            node_color=node_colors,
            node_size=3000,
            alpha=0.9,
            ax=ax
        )
        
        # ç»˜åˆ¶è¾¹
        # åŒºåˆ†å±‚çº§è¾¹å’Œäº¤å‰è¿æ¥
        hierarchical_edges = []
        cross_edges = []
        
        for edge in self.G.edges():
            source_level = self.G.nodes[edge[0]].get('level', 0)
            target_level = self.G.nodes[edge[1]].get('level', 0)
            
            # æ£€æŸ¥æ˜¯å¦æ˜¯å‘ä¸‹è¿æ¥ï¼ˆå±‚çº§ï¼‰æˆ–è·¨åˆ†æ”¯
            if target_level == source_level + 1:
                hierarchical_edges.append(edge)
            else:
                cross_edges.append(edge)
        
        # ç»˜åˆ¶å±‚çº§è¾¹ï¼ˆå®çº¿ï¼‰
        nx.draw_networkx_edges(
            self.G, pos,
            edgelist=hierarchical_edges,
            edge_color='#666666',
            width=2,
            arrows=True,
            arrowsize=20,
            arrowstyle='->',
            connectionstyle='arc3,rad=0.1',
            ax=ax
        )
        
        # ç»˜åˆ¶äº¤å‰è¾¹ï¼ˆè™šçº¿ï¼Œä¸åŒé¢œè‰²ï¼‰
        if cross_edges:
            nx.draw_networkx_edges(
                self.G, pos,
                edgelist=cross_edges,
                edge_color='#E74C3C',
                width=1.5,
                style='dashed',
                arrows=True,
                arrowsize=15,
                arrowstyle='->',
                connectionstyle='arc3,rad=0.2',
                ax=ax
            )
        
        # ç»˜åˆ¶èŠ‚ç‚¹æ ‡ç­¾
        labels = {node: self.G.nodes[node]['label'] for node in self.G.nodes()}
        nx.draw_networkx_labels(
            self.G, pos,
            labels=labels,
            font_size=9,
            font_weight='bold',
            ax=ax
        )
        
        # ç»˜åˆ¶è¾¹æ ‡ç­¾ï¼ˆå…³ç³»ï¼‰
        edge_labels = {(u, v): d['label'] for u, v, d in self.G.edges(data=True)}
        nx.draw_networkx_edge_labels(
            self.G, pos,
            edge_labels=edge_labels,
            font_size=7,
            label_pos=0.5,
            ax=ax
        )
        
        ax.set_title(f"æ¦‚å¿µå›¾è°±: {self.cmap.title}", fontsize=16, fontweight='bold', pad=20)
        ax.axis('off')
        
        # æ·»åŠ å›¾ä¾‹
        legend_elements = [
            plt.Line2D([0], [0], marker='o', color='w', markerfacecolor=color, 
                      markersize=12, label=f'å±‚çº§ {level}')
            for level, color in level_colors.items() if level <= max(c.level for c in self.cmap.concepts.values())
        ]
        legend_elements.append(plt.Line2D([0], [0], color='#666666', linewidth=2, label='å±‚çº§å…³ç³»'))
        legend_elements.append(plt.Line2D([0], [0], color='#E74C3C', linewidth=1.5, linestyle='--', label='äº¤å‰è¿æ¥'))
        
        ax.legend(handles=legend_elements, loc='upper left', bbox_to_anchor=(0, 1))
        
        plt.tight_layout()
        return fig, ax
    
    def _hierarchical_layout(self) -> dict:
        """è®¡ç®—å±‚çº§å¸ƒå±€"""
        pos = {}
        
        # æŒ‰å±‚çº§åˆ†ç»„èŠ‚ç‚¹
        level_nodes = {}
        for node in self.G.nodes():
            level = self.G.nodes[node].get('level', 0)
            if level not in level_nodes:
                level_nodes[level] = []
            level_nodes[level].append(node)
        
        # å‚ç›´åˆ†å±‚
        max_level = max(level_nodes.keys())
        for level, nodes in level_nodes.items():
            y = 1 - (level / max(max_level, 1))
            n = len(nodes)
            for i, node in enumerate(nodes):
                # æ°´å¹³åˆ†å¸ƒ
                if n > 1:
                    x = (i / (n - 1)) if n > 1 else 0.5
                    # å±…ä¸­è°ƒæ•´
                    x = x * 0.8 + 0.1
                else:
                    x = 0.5
                pos[node] = (x, y)
        
        return pos
    
    def export_to_dot(self, filepath: str):
        """å¯¼å‡ºä¸ºGraphviz DOTæ ¼å¼"""
        lines = [f'digraph "{self.cmap.title}" {{']
        lines.append('  rankdir=TB;')
        lines.append('  node [shape=box, style="rounded,filled", fillcolor=lightblue];')
        lines.append('  edge [color="#666666"];')
        lines.append('')
        
        # æ·»åŠ èŠ‚ç‚¹
        for concept in self.cmap.concepts.values():
            level_colors = {0: '#FF6B6B', 1: '#4ECDC4', 2: '#45B7D1', 3: '#96CEB4', 4: '#FFEAA7'}
            color = level_colors.get(concept.level, '#DDA0DD')
            lines.append(f'  "{concept.id}" [label="{concept.label}", fillcolor="{color}"];')
        
        lines.append('')
        
        # æ·»åŠ è¾¹
        for prop in self.cmap.propositions.values():
            source = self.cmap.concepts.get(prop.source_id)
            target = self.cmap.concepts.get(prop.target_id)
            if source and target:
                lines.append(f'  "{prop.source_id}" -> "{prop.target_id}" '
                           f'[label="{prop.linking_phrase}"];')
        
        lines.append('}')
        
        with open(filepath, 'w', encoding='utf-8') as f:
            f.write('\n'.join(lines))
        
        print(f"å·²å¯¼å‡ºåˆ°: {filepath}")


# ä½¿ç”¨ç¤ºä¾‹
def demo_visualization():
    """æ¼”ç¤ºæ¦‚å¿µå›¾è°±å¯è§†åŒ–"""
    cmap = create_microservices_concept_map()
    
    visualizer = ConceptMapVisualizer(cmap)
    fig, ax = visualizer.visualize(figsize=(18, 14), layout='hierarchical')
    
    plt.savefig('concept_map_visualization.png', dpi=150, bbox_inches='tight')
    plt.show()
    
    # å¯¼å‡ºDOTæ ¼å¼
    visualizer.export_to_dot('microservices_concept_map.dot')


if __name__ == "__main__":
    demo_visualization()
```

### 3.3 æ¦‚å¿µå›¾è°±åˆ†æå·¥å…·

```python
from collections import defaultdict, Counter
import pandas as pd

class ConceptMapAnalyzer:
    """æ¦‚å¿µå›¾è°±åˆ†æå·¥å…·"""
    
    def __init__(self, cmap: ConceptMap):
        self.cmap = cmap
        self.G = nx.DiGraph()
        self._build_graph()
    
    def _build_graph(self):
        """æ„å»ºå›¾"""
        for concept in self.cmap.concepts.values():
            self.G.add_node(concept.id, **concept.__dict__)
        for prop in self.cmap.propositions.values():
            self.G.add_edge(prop.source_id, prop.target_id, **prop.__dict__)
    
    def analyze_centrality(self) -> pd.DataFrame:
        """åˆ†ææ¦‚å¿µä¸­å¿ƒæ€§"""
        # åº¦ä¸­å¿ƒæ€§
        in_degree = dict(self.G.in_degree())
        out_degree = dict(self.G.out_degree())
        
        # æ¥è¿‘ä¸­å¿ƒæ€§ï¼ˆå¯¹äºæœ‰å‘å›¾ï¼‰
        try:
            closeness = nx.closeness_centrality(self.G)
        except:
            closeness = {n: 0 for n in self.G.nodes()}
        
        # ä»‹æ•°ä¸­å¿ƒæ€§
        try:
            betweenness = nx.betweenness_centrality(self.G)
        except:
            betweenness = {n: 0 for n in self.G.nodes()}
        
        # æ•´åˆç»“æœ
        data = []
        for concept_id in self.G.nodes():
            concept = self.cmap.concepts.get(concept_id)
            data.append({
                'concept': concept.label if concept else concept_id,
                'in_degree': in_degree.get(concept_id, 0),
                'out_degree': out_degree.get(concept_id, 0),
                'closeness': round(closeness.get(concept_id, 0), 4),
                'betweenness': round(betweenness.get(concept_id, 0), 4),
                'total_degree': in_degree.get(concept_id, 0) + out_degree.get(concept_id, 0)
            })
        
        df = pd.DataFrame(data)
        return df.sort_values('betweenness', ascending=False)
    
    def detect_clusters(self) -> List[Set[str]]:
        """æ£€æµ‹æ¦‚å¿µèšç±»ï¼ˆå°†æ— å‘å›¾ç”¨äºç¤¾åŒºæ£€æµ‹ï¼‰"""
        undirected = self.G.to_undirected()
        
        try:
            from networkx.algorithms import community
            clusters = community.greedy_modularity_communities(undirected)
            return [set(c) for c in clusters]
        except:
            # ç®€å•è¿é€šåˆ†é‡ä½œä¸ºå¤‡é€‰
            return list(nx.connected_components(undirected))
    
    def find_knowledge_gaps(self) -> List[Dict]:
        """è¯†åˆ«æ½œåœ¨çš„çŸ¥è¯†ç¼ºå£"""
        gaps = []
        
        # 1. å­¤ç«‹èŠ‚ç‚¹ï¼ˆæ— è¿æ¥çš„æ¦‚å¿µï¼‰
        for node in self.G.nodes():
            if self.G.degree(node) == 0:
                concept = self.cmap.concepts.get(node)
                gaps.append({
                    'type': 'å­¤ç«‹æ¦‚å¿µ',
                    'concept': concept.label if concept else node,
                    'suggestion': 'è€ƒè™‘åˆ é™¤æˆ–å»ºç«‹ä¸å…¶ä»–æ¦‚å¿µçš„å…³ç³»'
                })
        
        # 2. å±‚çº§è·³è·ƒï¼ˆè·³è¿‡ä¸­é—´å±‚çº§çš„è¿æ¥ï¼‰
        for edge in self.G.edges():
            source_level = self.G.nodes[edge[0]].get('level', 0)
            target_level = self.G.nodes[edge[1]].get('level', 0)
            
            if abs(target_level - source_level) > 2:
                source_concept = self.cmap.concepts.get(edge[0])
                target_concept = self.cmap.concepts.get(edge[1])
                gaps.append({
                    'type': 'å±‚çº§è·³è·ƒ',
                    'concept': f"{source_concept.label} -> {target_concept.label}",
                    'suggestion': f'è€ƒè™‘æ·»åŠ å±‚çº§{source_level+1}çš„ä¸­ä»‹æ¦‚å¿µ'
                })
        
        # 3. ç¼ºå°‘äº¤å‰è¿æ¥çš„ä¸åŒåˆ†æ”¯
        # ç®€åŒ–ï¼šæ£€æŸ¥é«˜åº¦ç‹¬ç«‹çš„æ¦‚å¿µç»„
        clusters = self.detect_clusters()
        if len(clusters) > 1:
            gaps.append({
                'type': 'çŸ¥è¯†å­¤å²›',
                'concept': f'æ£€æµ‹åˆ°{len(clusters)}ä¸ªç‹¬ç«‹çš„çŸ¥è¯†ç°‡',
                'suggestion': 'è€ƒè™‘æ·»åŠ ä¸åŒç°‡ä¹‹é—´çš„äº¤å‰è¿æ¥'
            })
        
        return gaps
    
    def generate_study_guide(self) -> str:
        """åŸºäºæ¦‚å¿µå›¾è°±ç”Ÿæˆå­¦ä¹ æŒ‡å—"""
        lines = [f"# {self.cmap.title} å­¦ä¹ æŒ‡å—", ""]
        lines.append(f"**ç„¦ç‚¹é—®é¢˜**: {self.cmap.focus_question}")
        lines.append("")
        
        # æŒ‰å±‚çº§ç»„ç»‡
        level_concepts = defaultdict(list)
        for concept in self.cmap.concepts.values():
            level_concepts[concept.level].append(concept)
        
        # ç”Ÿæˆå­¦ä¹ è·¯å¾„
        lines.append("## å­¦ä¹ è·¯å¾„")
        lines.append("")
        
        for level in sorted(level_concepts.keys()):
            lines.append(f"### å±‚çº§ {level}")
            lines.append("")
            
            for concept in level_concepts[level]:
                lines.append(f"#### {concept.label}")
                if concept.description:
                    lines.append(f"- **å®šä¹‰**: {concept.description}")
                
                # ç›¸å…³å…³ç³»
                parents = self.cmap.get_parents(concept.id)
                children = self.cmap.get_children(concept.id)
                
                if parents:
                    parent_names = [p.label for p in parents]
                    lines.append(f"- **ä¸Šä½æ¦‚å¿µ**: {', '.join(parent_names)}")
                
                if children:
                    children_names = [c.label for c in children[:5]]  # æœ€å¤šæ˜¾ç¤º5ä¸ª
                    lines.append(f"- **ä¸‹ä½æ¦‚å¿µ**: {', '.join(children_names)}")
                
                if concept.examples:
                    lines.append(f"- **ç¤ºä¾‹**: {', '.join(concept.examples)}")
                
                lines.append("")
        
        # äº¤å‰è¿æ¥
        cross_links = self.cmap.find_cross_links()
        if cross_links:
            lines.append("## é‡è¦å…³è”")
            lines.append("")
            for prop in cross_links[:10]:  # æœ€å¤šæ˜¾ç¤º10ä¸ª
                statement = prop.to_statement(self.cmap.concepts)
                lines.append(f"- {statement}")
            lines.append("")
        
        return '\n'.join(lines)


def analyze_concept_map(cmap: ConceptMap):
    """å®Œæ•´åˆ†ææ¦‚å¿µå›¾è°±"""
    analyzer = ConceptMapAnalyzer(cmap)
    
    print("=" * 60)
    print(f"æ¦‚å¿µå›¾è°±åˆ†ææŠ¥å‘Š: {cmap.title}")
    print("=" * 60)
    
    # ä¸­å¿ƒæ€§åˆ†æ
    print("\nğŸ“Š æ¦‚å¿µä¸­å¿ƒæ€§åˆ†æ (Top 10):")
    centrality = analyzer.analyze_centrality().head(10)
    print(centrality.to_string(index=False))
    
    # çŸ¥è¯†ç¼ºå£
    print("\nâš ï¸ æ½œåœ¨çŸ¥è¯†ç¼ºå£:")
    gaps = analyzer.find_knowledge_gaps()
    for gap in gaps:
        print(f"  [{gap['type']}] {gap['concept']}")
        print(f"    å»ºè®®: {gap['suggestion']}")
    
    # èšç±»åˆ†æ
    print("\nğŸ” çŸ¥è¯†èšç±»:")
    clusters = analyzer.detect_clusters()
    for i, cluster in enumerate(clusters, 1):
        concept_names = [cmap.concepts.get(n).label for n in cluster if n in cmap.concepts]
        print(f"  èšç±» {i} ({len(cluster)} ä¸ªæ¦‚å¿µ): {', '.join(concept_names[:5])}")
    
    # ç”Ÿæˆå­¦ä¹ æŒ‡å—
    guide = analyzer.generate_study_guide()
    with open(f"{cmap.title}_study_guide.md", 'w', encoding='utf-8') as f:
        f.write(guide)
    print(f"\nğŸ“„ å­¦ä¹ æŒ‡å—å·²ä¿å­˜: {cmap.title}_study_guide.md")


if __name__ == "__main__":
    cmap = create_microservices_concept_map()
    analyze_concept_map(cmap)
```

---

## 4. èµ„æºç´¢å¼•

### 4.1 è½¯ä»¶å·¥å…·

| å·¥å…·åç§° | ç±»å‹ | ç‰¹ç‚¹ | é€‚ç”¨å¹³å° |
|----------|------|------|----------|
| **CmapTools** | ä¸“ä¸šå·¥å…· | å­¦æœ¯ç ”ç©¶æ ‡å‡†ï¼Œæ”¯æŒåä½œ | Windows/Mac/Linux |
| **XMind** | æ€ç»´å¯¼å›¾ | åŠŸèƒ½ä¸°å¯Œï¼Œæ¨¡æ¿å¤šæ · | è·¨å¹³å° |
| **MindMeister** | åœ¨çº¿å·¥å…· | å®æ—¶åä½œï¼Œäº‘åŒæ­¥ | Web |
| **Lucidchart** | åœ¨çº¿å·¥å…· | ä¸“ä¸šå›¾è¡¨ï¼Œå›¢é˜Ÿåä½œ | Web |
| **draw.io** | å¼€æºå…è´¹ | å®Œå…¨å…è´¹ï¼ŒåŠŸèƒ½å¼ºå¤§ | Web/Desktop |
| **Obsidian** | çŸ¥è¯†ç®¡ç† | åŒå‘é“¾æ¥+å›¾è°±è§†å›¾ | è·¨å¹³å° |
| **yFiles** | å¼€å‘åº“ | å¯ç¼–ç¨‹ï¼Œå•†ä¸šçº§ | Java/JS/.NET |

### 4.2 å­¦ä¹ èµ„æº

**å…¥é—¨ä¹¦ç±**ï¼š
- ã€ŠLearning How to Learnã€‹ - Barbara Oakley
- ã€ŠThe Art of Changing the Brainã€‹ - James E. Zull

**å­¦æœ¯è®ºæ–‡**ï¼š
- Novak, J. D. & CaÃ±as, A. J. - *The Theory Underlying Concept Maps* (2006)
- Ausubel, D. P. - *Educational Psychology: A Cognitive View* (1968)

**åœ¨çº¿èµ„æº**ï¼š
- Cmapå®˜ç½‘ (cmap.ihmc.us) - ç†è®ºã€å·¥å…·å’Œæ¡ˆä¾‹
- Florida Institute for Human & Machine Cognition - ç ”ç©¶è®ºæ–‡

---

## 5. å…³è”çŸ¥è¯†

### 5.1 ä¸Šæ¸¸å…³è”

```
C02_Concept_Mapping
â”œâ”€â”€ C01_Spaced_Repetition
â”‚   â””â”€â”€ æ¦‚å¿µå›¾è°±å¯ä½œä¸ºé—´éš”é‡å¤å¡ç‰‡çš„çŸ¥è¯†æ¡†æ¶
â”œâ”€â”€ A03_Design_Architecture/B05_System_Modeling
â”‚   â””â”€â”€ ç³»ç»Ÿå»ºæ¨¡æ–¹æ³•ä¸æ¦‚å¿µå›¾è°±çš„æŠ€æœ¯å®ç°
â””â”€â”€ A06_Technical_Intuition/B01_CS_Theories
    â””â”€â”€ è®¤çŸ¥ç§‘å­¦ç†è®ºæ”¯æ’‘
```

### 5.2 ä¸‹æ¸¸åº”ç”¨

```
C02_Concept_Mapping
â”œâ”€â”€ B02_Content_Strategy/C01_Atomic_Notes
â”‚   â””â”€â”€ æ¦‚å¿µåˆ†è§£ä¸ºåŸå­ç¬”è®°
â”œâ”€â”€ C03_Knowledge_Graphs
â”‚   â””â”€â”€ æ¦‚å¿µå›¾è°±çš„æ•°æ®ç»“æ„æ‰©å±•
â””â”€â”€ A99_Sandbox/B01_Sandbox_Drafts/C02_Architecture_Sketches
    â””â”€â”€ æ¶æ„è‰å›¾çš„æ¦‚å¿µç»„ç»‡
```

---

## 6. å­¦ä¹ å»ºè®®

### 6.1 æ„å»ºæŠ€å·§

1. **ä»ç„¦ç‚¹é—®é¢˜å¼€å§‹**ï¼šæ¯å¼ æ¦‚å¿µå›¾è°±éƒ½åº”è¯¥å›´ç»•ä¸€ä¸ªæ˜ç¡®çš„é—®é¢˜æ„å»º
2. **éµå¾ª"ç”±å¤§åˆ°å°"**ï¼šå…ˆç¡®å®šæœ€ä¸€èˆ¬çš„æ¦‚å¿µï¼Œå†é€æ­¥ç»†åŒ–
3. **é‡è§†äº¤å‰è¿æ¥**ï¼šä¸åŒåˆ†æ”¯é—´çš„è¿æ¥å¾€å¾€ä½“ç°æ·±å±‚ç†è§£
4. **è¿­ä»£å®Œå–„**ï¼šæ¦‚å¿µå›¾è°±æ˜¯åŠ¨æ€æ¼”åŒ–çš„ï¼Œéšå­¦ä¹ æ·±å…¥æŒç»­æ›´æ–°

### 6.2 å¸¸è§é”™è¯¯

| é”™è¯¯ç±»å‹ | è¡¨ç° | è§£å†³æ–¹æ¡ˆ |
|----------|------|----------|
| æ¦‚å¿µè¿‡äºå®½æ³› | ä¸€ä¸ªæ¦‚å¿µåŒ…å«å¤ªå¤šå†…å®¹ | æ‹†åˆ†ä¸ºå¤šä¸ªå­æ¦‚å¿µ |
| å…³ç³»ä¸æ˜ç¡® | ä½¿ç”¨æ¨¡ç³Šè¿æ¥è¯ | ä½¿ç”¨ç²¾ç¡®çš„åŠ¨è¯æˆ–çŸ­è¯­ |
| ç¼ºå°‘å±‚çº§ | æ‰€æœ‰æ¦‚å¿µåœ¨åŒä¸€å±‚çº§ | æ˜ç¡®æ¦‚å¿µçš„æŠ½è±¡ç¨‹åº¦ |
| è¿‡åº¦è¿æ¥ | æ¯ä¸ªæ¦‚å¿µéƒ½è¿æ¥åˆ°å…¶ä»–æ‰€æœ‰æ¦‚å¿µ | åªä¿ç•™æœ‰æ„ä¹‰çš„å…³ç³» |

### 6.3 å®è·µè·¯å¾„

**ç¬¬1å‘¨**ï¼šå­¦ä¹ åŸºç¡€ç†è®ºï¼Œç”¨çº¸è´¨å·¥å…·ç»ƒä¹ ç»˜åˆ¶ç®€å•æ¦‚å¿µå›¾è°±
**ç¬¬2-3å‘¨**ï¼šä½¿ç”¨CmapToolsæˆ–draw.ioç»˜åˆ¶æŠ€æœ¯ä¸»é¢˜çš„æ¦‚å¿µå›¾è°±
**ç¬¬4å‘¨+**ï¼šå°†æ¦‚å¿µå›¾è°±èå…¥æ—¥å¸¸å·¥ä½œæµï¼Œä¸å…¶ä»–çŸ¥è¯†å·¥å…·ç»“åˆ

---

*æœ€åæ›´æ–°ï¼š2026-01-30*
*ç»´æŠ¤è€…ï¼šZCO Knowledge Ops Team*

# C01_Agile_Methodologies - æ•æ·æ–¹æ³•è®º

## 1. ä¸»é¢˜å®šä½

### 1.1 å®šä¹‰ä¸èŒƒå›´

æ•æ·æ–¹æ³•è®ºæ˜¯ä¸€å¥—ä»¥äººä¸ºæ ¸å¿ƒã€è¿­ä»£å¢é‡å¼çš„è½¯ä»¶å¼€å‘å“²å­¦å’Œå®è·µæ¡†æ¶ã€‚æœ¬çŸ¥è¯†å•å…ƒèšç„¦äºæ•æ·å®£è¨€ï¼ˆAgile Manifestoï¼‰çš„æ ¸å¿ƒä»·å€¼è§‚å’ŒåäºŒé¡¹åŸåˆ™ï¼Œä»¥åŠScrumã€Kanbanã€XPç­‰ä¸»æµæ•æ·æ¡†æ¶çš„å®æ–½ç»†èŠ‚ã€‚æ¶µç›–ä»éœ€æ±‚ç®¡ç†ã€è¿­ä»£è§„åˆ’åˆ°æŒç»­æ”¹è¿›çš„å®Œæ•´è½¯ä»¶å¼€å‘ç”Ÿå‘½å‘¨æœŸç®¡ç†æ–¹æ³•è®ºã€‚

### 1.2 ä¸šåŠ¡ä»·å€¼

æ•æ·æ–¹æ³•è®ºé€šè¿‡çŸ­å‘¨æœŸäº¤ä»˜ã€å¿«é€Ÿåé¦ˆå’ŒæŒç»­é€‚åº”å˜åŒ–ï¼Œå¸®åŠ©ç»„ç»‡å®ç°ï¼š

- **ä¸šåŠ¡å“åº”é€Ÿåº¦æå‡**ï¼šç¼©çŸ­ä»éœ€æ±‚åˆ°ä¸Šçº¿çš„å‘¨æœŸï¼Œå¿«é€Ÿå“åº”å¸‚åœºå˜åŒ–
- **äº¤ä»˜ä»·å€¼æœ€å¤§åŒ–**ï¼šä¼˜å…ˆäº¤ä»˜é«˜ä»·å€¼åŠŸèƒ½ï¼Œç¡®ä¿æŠ•èµ„å›æŠ¥ç‡
- **é£é™©æ—©æœŸæš´éœ²**ï¼šé€šè¿‡é¢‘ç¹äº¤ä»˜å’Œåé¦ˆï¼Œå°½æ—©å‘ç°å’Œè§£å†³é—®é¢˜
- **å›¢é˜Ÿèµ‹èƒ½ä¸è‡ªç»„ç»‡**ï¼šæ¿€å‘å›¢é˜Ÿåˆ›é€ åŠ›ï¼Œæå‡æˆå‘˜å‚ä¸åº¦å’Œæ»¡æ„åº¦
- **å®¢æˆ·æ»¡æ„åº¦æå‡**ï¼šæŒç»­äº¤ä»˜å¯ç”¨è½¯ä»¶ï¼Œå»ºç«‹ä¿¡ä»»å…³ç³»

### 1.3 é€‚ç”¨åœºæ™¯

| åœºæ™¯ç±»å‹ | é€‚ç”¨æ€§ | è¯´æ˜ |
|---------|-------|------|
| äº’è”ç½‘äº§å“ | â­â­â­â­â­ | éœ€æ±‚å˜åŒ–å¿«ï¼Œéœ€è¦å¿«é€Ÿè¿­ä»£éªŒè¯ |
| ä¼ä¸šæ•°å­—åŒ–è½¬å‹ | â­â­â­â­ | å¤æ‚ä¸šåŠ¡åœºæ™¯ï¼Œéœ€è¦åˆ†é˜¶æ®µäº¤ä»˜ |
| åˆ›ä¸šå›¢é˜Ÿ | â­â­â­â­â­ | èµ„æºæœ‰é™ï¼Œéœ€è¦æœ€å¤§åŒ–äº¤ä»˜ä»·å€¼ |
| å¤§å‹é—ç•™ç³»ç»Ÿæ”¹é€  | â­â­â­ | éœ€è¦æ¸è¿›å¼è¿ç§»ç­–ç•¥ |
| å¼ºç›‘ç®¡è¡Œä¸š | â­â­ | éœ€è¦ä¸åˆè§„è¦æ±‚å¹³è¡¡é€‚é… |

## 2. æ ¸å¿ƒæ¦‚å¿µ

### 2.1 æ•æ·å®£è¨€ä¸ä»·å€¼è§‚

```
æˆ‘ä»¬æ­£åœ¨é€šè¿‡äº²èº«å®è·µå’Œå¸®åŠ©ä»–äººå®è·µï¼Œæ­ç¤ºæ›´å¥½çš„è½¯ä»¶å¼€å‘æ–¹æ³•ã€‚
é€šè¿‡è¿™é¡¹å·¥ä½œï¼Œæˆ‘ä»¬è®¤ä¸ºï¼š

ä¸ªä½“å’Œäº’åŠ¨ é«˜äº æµç¨‹å’Œå·¥å…·
å·¥ä½œçš„è½¯ä»¶ é«˜äº è¯¦å°½çš„æ–‡æ¡£
å®¢æˆ·åˆä½œ é«˜äº åˆåŒè°ˆåˆ¤
å“åº”å˜åŒ– é«˜äº éµå¾ªè®¡åˆ’

ä¹Ÿå°±æ˜¯è¯´ï¼Œå°½ç®¡å³é¡¹æœ‰å…¶ä»·å€¼ï¼Œæˆ‘ä»¬æ›´é‡è§†å·¦é¡¹çš„ä»·å€¼ã€‚
```

### 2.2 Scrum æ¡†æ¶

#### 2.2.1 æ ¸å¿ƒè§’è‰²

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      Scrum å›¢é˜Ÿç»“æ„                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚   â”‚ Product      â”‚    â”‚ Scrum        â”‚    â”‚ Development  â”‚ â”‚
â”‚   â”‚ Owner        â”‚â—„â”€â”€â–ºâ”‚ Master       â”‚â—„â”€â”€â–ºâ”‚ Team         â”‚ â”‚
â”‚   â”‚              â”‚    â”‚              â”‚    â”‚              â”‚ â”‚
â”‚   â”‚ â€¢ å®šä¹‰æ„¿æ™¯    â”‚    â”‚ â€¢ æµç¨‹å®ˆæŠ¤    â”‚    â”‚ â€¢ è·¨èŒèƒ½      â”‚ â”‚
â”‚   â”‚ â€¢ ç®¡ç†å¾…åŠ    â”‚    â”‚ â€¢ éšœç¢ç§»é™¤    â”‚    â”‚ â€¢ è‡ªç»„ç»‡      â”‚ â”‚
â”‚   â”‚ â€¢ ä¼˜å…ˆçº§æ’åº  â”‚    â”‚ â€¢ å¼•å¯¼ä¼šè®®    â”‚    â”‚ â€¢ è¿­ä»£äº¤ä»˜    â”‚ â”‚
â”‚   â”‚ â€¢ éªŒæ”¶æˆæœ    â”‚    â”‚ â€¢ æ•™ç»ƒå›¢é˜Ÿ    â”‚    â”‚ â€¢ è´¨é‡å†…å»º    â”‚ â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### 2.2.2 å·¥ä»¶ä¸äº‹ä»¶

```
Scrum äº‹ä»¶æ—¶é—´ç›’ï¼š

Sprint (1-4å‘¨)
â”œâ”€â”€ Sprint Planning     (8å°æ—¶/æœˆ)
â”œâ”€â”€ Daily Scrum         (15åˆ†é’Ÿ/å¤©)
â”œâ”€â”€ Sprint Review       (4å°æ—¶/æœˆ)
â”œâ”€â”€ Sprint Retrospective (3å°æ—¶/æœˆ)
â””â”€â”€ Backlog Refinement  (10% Sprintæ—¶é—´)
```

### 2.3 Kanban æ–¹æ³•

```
Kanban æ ¸å¿ƒåŸåˆ™ï¼š

1. å¯è§†åŒ–å·¥ä½œæµç¨‹
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚  å¾…åŠ  â”‚  åˆ†æ  â”‚  å¼€å‘  â”‚  æµ‹è¯•  â”‚  å®Œæˆ â”‚
   â”‚   5    â”‚   2    â”‚   3    â”‚   2    â”‚   âˆ   â”‚  â† WIPé™åˆ¶
   â”‚        â”‚   â–“â–“   â”‚  â–“â–“â–“   â”‚   â–“â–“   â”‚  â˜…â˜…â˜…  â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

2. é™åˆ¶åœ¨åˆ¶å“ (WIP)
3. ç®¡ç†æµåŠ¨
4. æ˜ç¡®æµç¨‹ç­–ç•¥
5. å»ºç«‹åé¦ˆå¾ªç¯
6. åä½œæ”¹è¿›
```

### 2.4 æé™ç¼–ç¨‹ (XP)

```
XP æ ¸å¿ƒå®è·µç¯ï¼š

              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚   è®¡åˆ’æ¸¸æˆ      â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                  â”‚                  â”‚
    â–¼                  â–¼                  â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ç®€å•è®¾è®¡ â”‚â—„â”€â”€â”€â–ºâ”‚æµ‹è¯•é©±åŠ¨ â”‚â—„â”€â”€â”€â”€â”€â–ºâ”‚æŒç»­é›†æˆ â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜     â”‚å¼€å‘(TDD)â”‚       â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
     â”‚          â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜            â”‚
     â”‚               â”‚                 â”‚
     â–¼               â–¼                 â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚é‡æ„     â”‚     â”‚ç»“å¯¹ç¼–ç¨‹ â”‚       â”‚ä»£ç é›†ä½“ â”‚
â”‚         â”‚     â”‚         â”‚       â”‚æ‰€æœ‰åˆ¶   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.5 è§„æ¨¡åŒ–æ•æ·æ¡†æ¶

| æ¡†æ¶ | é€‚ç”¨è§„æ¨¡ | æ ¸å¿ƒç‰¹ç‚¹ |
|-----|---------|---------|
| SAFe | å¤§å‹ç»„ç»‡ | ç²¾ç›Š-æ•æ·åŸåˆ™ï¼Œä»·å€¼æµå¯¹é½ |
| LeSS | ä¸­å¤§å‹ä¼ä¸š | ç®€åŒ–Scrumæ‰©å±•ï¼Œå‡å°‘å¤æ‚æ€§ |
| Nexus | å¤šå›¢é˜ŸScrum | é›†æˆå›¢é˜Ÿåè°ƒä¾èµ– |
| Spotifyæ¨¡å‹ | ä¸­å‹ç»„ç»‡ | éƒ¨è½-å°é˜Ÿ-åˆ†ä¼š-å…¬ä¼šç»“æ„ |

## 3. æŠ€æœ¯å®è·µ

### 3.1 ç”¨æˆ·æ•…äº‹å®è·µ

#### 3.1.1 ç”¨æˆ·æ•…äº‹å¡ç‰‡æ ¼å¼

```markdown
## ç”¨æˆ·æ•…äº‹æ¨¡æ¿

### æ•…äº‹æ ‡é¢˜
ä½œä¸º [è§’è‰²]ï¼Œæˆ‘æƒ³è¦ [åŠŸèƒ½]ï¼Œä»¥ä¾¿äº [ä»·å€¼]

### éªŒæ”¶æ ‡å‡† (AC)
- [ ] ç»™å®š [ä¸Šä¸‹æ–‡]ï¼Œå½“ [äº‹ä»¶]ï¼Œé‚£ä¹ˆ [ç»“æœ1]
- [ ] ç»™å®š [ä¸Šä¸‹æ–‡]ï¼Œå½“ [äº‹ä»¶]ï¼Œé‚£ä¹ˆ [ç»“æœ2]
- [ ] è¾¹ç•Œæƒ…å†µå¤„ç†

### æŠ€æœ¯ä»»åŠ¡æ‹†åˆ†
- [ ] æ•°æ®åº“è®¾è®¡
- [ ] APIæ¥å£å¼€å‘
- [ ] å‰ç«¯é¡µé¢å®ç°
- [ ] å•å…ƒæµ‹è¯•ç¼–å†™
- [ ] é›†æˆæµ‹è¯•

### ä¼°ç®—
- æ•…äº‹ç‚¹ï¼š5
- é¢„ä¼°å·¥æ—¶ï¼š16å°æ—¶

### ä¼˜å…ˆçº§
- MoSCoWï¼šMust Have
- WSJFåˆ†æ•°ï¼š23.5
```

#### 3.1.2 Python ç”¨æˆ·æ•…äº‹ç®¡ç†å·¥å…·

```python
#!/usr/bin/env python3
"""
ç”¨æˆ·æ•…äº‹ç®¡ç†ç³»ç»Ÿ
æ”¯æŒæ•…äº‹ç‚¹ä¼°ç®—ã€ä¼˜å…ˆçº§æ’åºå’ŒSprintè§„åˆ’
"""

from dataclasses import dataclass, field
from enum import Enum
from typing import List, Optional
from datetime import datetime, timedelta
import json


class Priority(Enum):
    MUST_HAVE = 1
    SHOULD_HAVE = 2
    COULD_HAVE = 3
    WONT_HAVE = 4


class Status(Enum):
    BACKLOG = "å¾…åŠ"
    SELECTED = "å·²é€‰"
    IN_PROGRESS = "è¿›è¡Œä¸­"
    DONE = "å·²å®Œæˆ"


@dataclass
class UserStory:
    """ç”¨æˆ·æ•…äº‹æ•°æ®æ¨¡å‹"""
    id: str
    title: str
    role: str
    feature: str
    value: str
    story_points: int
    priority: Priority
    status: Status = Status.BACKLOG
    acceptance_criteria: List[str] = field(default_factory=list)
    tasks: List[dict] = field(default_factory=list)
    created_at: datetime = field(default_factory=datetime.now)
    completed_at: Optional[datetime] = None
    
    def to_dict(self) -> dict:
        """è½¬æ¢ä¸ºå­—å…¸æ ¼å¼"""
        return {
            "id": self.id,
            "title": self.title,
            "role": self.role,
            "feature": self.feature,
            "value": self.value,
            "story_points": self.story_points,
            "priority": self.priority.name,
            "status": self.status.value,
            "acceptance_criteria": self.acceptance_criteria,
            "tasks": self.tasks,
            "created_at": self.created_at.isoformat(),
            "completed_at": self.completed_at.isoformat() if self.completed_at else None
        }
    
    def calculate_wsjf(self, user_business_value: float, 
                       time_criticality: float,
                       risk_reduction: float,
                       job_size: float) -> float:
        """
        è®¡ç®—WSJF (Weighted Shortest Job First) åˆ†æ•°
        ç”¨äºä¼˜å…ˆçº§æ’åº
        """
        if job_size == 0:
            return 0
        cost_of_delay = user_business_value + time_criticality + risk_reduction
        return round(cost_of_delay / job_size, 2)
    
    def __str__(self) -> str:
        return f"[{self.id}] {self.title} ({self.story_points}pts)"


class Sprint:
    """Sprintç®¡ç†ç±»"""
    
    def __init__(self, name: str, start_date: datetime, duration_weeks: int = 2):
        self.name = name
        self.start_date = start_date
        self.end_date = start_date + timedelta(weeks=duration_weeks)
        self.stories: List[UserStory] = []
        self.capacity = 0  # å›¢é˜Ÿå®¹é‡ï¼ˆæ•…äº‹ç‚¹ï¼‰
        
    def add_story(self, story: UserStory) -> bool:
        """æ·»åŠ æ•…äº‹åˆ°Sprintï¼Œæ£€æŸ¥å®¹é‡"""
        current_load = sum(s.story_points for s in self.stories)
        if current_load + story.story_points <= self.capacity:
            self.stories.append(story)
            story.status = Status.SELECTED
            return True
        return False
    
    def get_burndown_data(self) -> dict:
        """ç”Ÿæˆç‡ƒå°½å›¾æ•°æ®"""
        total_points = sum(s.story_points for s in self.stories)
        done_points = sum(s.story_points for s in self.stories 
                         if s.status == Status.DONE)
        remaining = total_points - done_points
        
        return {
            "sprint_name": self.name,
            "total_points": total_points,
            "completed_points": done_points,
            "remaining_points": remaining,
            "completion_percentage": round(done_points/total_points*100, 2) if total_points else 0
        }
    
    def export_to_json(self, filepath: str):
        """å¯¼å‡ºSprintæ•°æ®åˆ°JSON"""
        data = {
            "sprint": self.name,
            "start_date": self.start_date.isoformat(),
            "end_date": self.end_date.isoformat(),
            "capacity": self.capacity,
            "stories": [s.to_dict() for s in self.stories],
            "burndown": self.get_burndown_data()
        }
        with open(filepath, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class ProductBacklog:
    """äº§å“å¾…åŠåˆ—è¡¨ç®¡ç†"""
    
    def __init__(self):
        self.stories: List[UserStory] = []
        
    def add_story(self, story: UserStory):
        self.stories.append(story)
        
    def prioritize_by_wsjf(self) -> List[UserStory]:
        """æŒ‰WSJFåˆ†æ•°æ’åº"""
        return sorted(self.stories, 
                     key=lambda s: s.priority.value,
                     reverse=True)
    
    def filter_by_status(self, status: Status) -> List[UserStory]:
        """æŒ‰çŠ¶æ€è¿‡æ»¤"""
        return [s for s in self.stories if s.status == status]
    
    def generate_velocity_report(self, sprints: List[Sprint]) -> dict:
        """ç”Ÿæˆé€Ÿåº¦æŠ¥å‘Š"""
        velocities = []
        for sprint in sprints:
            completed = sum(s.story_points for s in sprint.stories 
                          if s.status == Status.DONE)
            velocities.append(completed)
        
        avg_velocity = sum(velocities) / len(velocities) if velocities else 0
        
        return {
            "sprint_velocities": velocities,
            "average_velocity": round(avg_velocity, 2),
            "predictability": self._calculate_predictability(velocities)
        }
    
    def _calculate_predictability(self, velocities: List[int]) -> float:
        """è®¡ç®—å¯é¢„æµ‹æ€§ï¼ˆå˜å¼‚ç³»æ•°å€’æ•°ï¼‰"""
        if len(velocities) < 2:
            return 0
        mean = sum(velocities) / len(velocities)
        variance = sum((v - mean) ** 2 for v in velocities) / len(velocities)
        std_dev = variance ** 0.5
        cv = std_dev / mean if mean else 0
        return round((1 - min(cv, 1)) * 100, 2)


# ä½¿ç”¨ç¤ºä¾‹
if __name__ == "__main__":
    # åˆ›å»ºäº§å“å¾…åŠåˆ—è¡¨
    backlog = ProductBacklog()
    
    # æ·»åŠ ç”¨æˆ·æ•…äº‹
    story1 = UserStory(
        id="US-001",
        title="ç”¨æˆ·ç™»å½•åŠŸèƒ½",
        role="æ³¨å†Œç”¨æˆ·",
        feature="é€šè¿‡é‚®ç®±å’Œå¯†ç ç™»å½•ç³»ç»Ÿ",
        value="å®‰å…¨è®¿é—®ä¸ªäººè´¦æˆ·",
        story_points=5,
        priority=Priority.MUST_HAVE,
        acceptance_criteria=[
            "è¾“å…¥æ­£ç¡®å‡­æ®æ—¶æˆåŠŸç™»å½•",
            "å¯†ç é”™è¯¯æ—¶æ˜¾ç¤ºå‹å¥½æç¤º",
            "æ”¯æŒ"è®°ä½æˆ‘"åŠŸèƒ½"
        ]
    )
    
    story2 = UserStory(
        id="US-002",
        title="å¯†ç é‡ç½®åŠŸèƒ½",
        role="å¿˜è®°å¯†ç çš„ç”¨æˆ·",
        feature="é€šè¿‡é‚®ç®±é‡ç½®å¯†ç ",
        value="æ¢å¤è´¦æˆ·è®¿é—®æƒé™",
        story_points=3,
        priority=Priority.SHOULD_HAVE
    )
    
    backlog.add_story(story1)
    backlog.add_story(story2)
    
    # åˆ›å»ºSprint
    sprint = Sprint(
        name="Sprint 1",
        start_date=datetime.now(),
        duration_weeks=2
    )
    sprint.capacity = 20  # å›¢é˜Ÿå®¹é‡20æ•…äº‹ç‚¹
    
    # è§„åˆ’Sprint
    for story in backlog.prioritize_by_wsjf():
        if sprint.add_story(story):
            print(f"âœ“ å·²æ·»åŠ  {story} åˆ° {sprint.name}")
        else:
            print(f"âœ— {story} è¶…å‡ºå®¹é‡ï¼Œç§»è‡³ä¸‹ä¸€Sprint")
    
    # å¯¼å‡ºæŠ¥å‘Š
    sprint.export_to_json("sprint_plan.json")
    print("\nSprintè§„åˆ’å·²å¯¼å‡ºåˆ° sprint_plan.json")
```

### 3.2 è¿­ä»£è§„åˆ’ä¸è¿½è¸ª

#### 3.2.1 Sprintè§„åˆ’è„šæœ¬

```python
#!/usr/bin/env python3
"""
Sprintè§„åˆ’è‡ªåŠ¨åŒ–å·¥å…·
é›†æˆJIRA APIè¿›è¡Œè¿­ä»£ç®¡ç†
"""

import requests
from datetime import datetime, timedelta
from typing import Dict, List, Optional
import os


class JiraSprintManager:
    """JIRA Sprintç®¡ç†å™¨"""
    
    def __init__(self, base_url: str, username: str, api_token: str):
        self.base_url = base_url.rstrip('/')
        self.auth = (username, api_token)
        self.headers = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }
    
    def get_active_sprint(self, board_id: int) -> Optional[Dict]:
        """è·å–æ´»è·ƒSprint"""
        url = f"{self.base_url}/rest/agile/1.0/board/{board_id}/sprint"
        params = {"state": "active"}
        
        response = requests.get(url, auth=self.auth, 
                              headers=self.headers, params=params)
        
        if response.status_code == 200:
            sprints = response.json().get("values", [])
            return sprints[0] if sprints else None
        return None
    
    def create_sprint(self, board_id: int, name: str, 
                     start_date: datetime, end_date: datetime) -> Dict:
        """åˆ›å»ºæ–°Sprint"""
        url = f"{self.base_url}/rest/agile/1.0/sprint"
        
        payload = {
            "name": name,
            "originBoardId": board_id,
            "startDate": start_date.strftime("%Y-%m-%dT%H:%M:%S.000+0800"),
            "endDate": end_date.strftime("%Y-%m-%dT%H:%M:%S.000+0800")
        }
        
        response = requests.post(url, auth=self.auth,
                               headers=self.headers, json=payload)
        response.raise_for_status()
        return response.json()
    
    def get_sprint_issues(self, sprint_id: int) -> List[Dict]:
        """è·å–Sprintä¸­çš„æ‰€æœ‰é—®é¢˜"""
        url = f"{self.base_url}/rest/agile/1.0/sprint/{sprint_id}/issue"
        
        issues = []
        start_at = 0
        max_results = 50
        
        while True:
            params = {"startAt": start_at, "maxResults": max_results}
            response = requests.get(url, auth=self.auth,
                                  headers=self.headers, params=params)
            
            if response.status_code != 200:
                break
                
            data = response.json()
            issues.extend(data.get("issues", []))
            
            if len(data.get("issues", [])) < max_results:
                break
            start_at += max_results
        
        return issues
    
    def generate_burndown_chart(self, sprint_id: int) -> Dict:
        """ç”Ÿæˆç‡ƒå°½å›¾æ•°æ®"""
        issues = self.get_sprint_issues(sprint_id)
        
        total_story_points = 0
        completed_points = 0
        
        for issue in issues:
            fields = issue.get("fields", {})
            points = fields.get("customfield_10016", 0) or 0  # æ•…äº‹ç‚¹å­—æ®µ
            status = fields.get("status", {}).get("name", "")
            
            total_story_points += points
            if status in ["Done", "Closed", "Resolved"]:
                completed_points += points
        
        return {
            "sprint_id": sprint_id,
            "total_issues": len(issues),
            "total_story_points": total_story_points,
            "completed_points": completed_points,
            "remaining_points": total_story_points - completed_points,
            "completion_rate": round(completed_points / total_story_points * 100, 2) 
                              if total_story_points else 0
        }


class SprintCapacityPlanner:
    """Sprintå®¹é‡è§„åˆ’å™¨"""
    
    def __init__(self, team_members: int, hours_per_day: float = 8):
        self.team_members = team_members
        self.hours_per_day = hours_per_day
        self.holidays = []
        
    def set_holidays(self, holidays: List[str]):
        """è®¾ç½®èŠ‚å‡æ—¥åˆ—è¡¨"""
        self.holidays = [datetime.strptime(h, "%Y-%m-%d").date() for h in holidays]
    
    def calculate_capacity(self, sprint_weeks: int = 2,
                          focus_factor: float = 0.7,
                          pto_days: Dict[str, int] = None) -> Dict:
        """
        è®¡ç®—Sprintå®¹é‡
        
        Args:
            sprint_weeks: Sprintå‘¨æ•°
            focus_factor: ä¸“æ³¨ç³»æ•°ï¼ˆè€ƒè™‘ä¼šè®®ç­‰ä¸­æ–­ï¼‰
            pto_days: æˆå‘˜ä¼‘å‡å¤©æ•° {æˆå‘˜å: å¤©æ•°}
        """
        # è®¡ç®—å·¥ä½œæ—¥
        today = datetime.now().date()
        total_days = sprint_weeks * 7
        end_date = today + timedelta(days=total_days)
        
        workdays = 0
        current = today
        while current < end_date:
            # è·³è¿‡å‘¨æœ«å’ŒèŠ‚å‡æ—¥
            if current.weekday() < 5 and current not in self.holidays:
                workdays += 1
            current += timedelta(days=1)
        
        # è®¡ç®—æ€»å¯ç”¨å·¥æ—¶
        total_available_hours = workdays * self.hours_per_day * self.team_members
        
        # å‡å»ä¼‘å‡æ—¶é—´
        pto_hours = sum(pto_days.values()) * self.hours_per_day if pto_days else 0
        
        # åº”ç”¨ä¸“æ³¨ç³»æ•°
        effective_hours = (total_available_hours - pto_hours) * focus_factor
        
        # ä¼°ç®—æ•…äº‹ç‚¹ï¼ˆå‡è®¾1æ•…äº‹ç‚¹=4å°æ—¶ï¼‰
        story_point_capacity = int(effective_hours / 4)
        
        return {
            "sprint_duration_weeks": sprint_weeks,
            "workdays": workdays,
            "total_available_hours": total_available_hours,
            "pto_hours": pto_hours,
            "focus_factor": focus_factor,
            "effective_hours": round(effective_hours, 2),
            "story_point_capacity": story_point_capacity,
            "team_members": self.team_members,
            "holidays_in_sprint": [str(h) for h in self.holidays 
                                   if today <= h < end_date]
        }


# CLIå·¥å…·
if __name__ == "__main__":
    import argparse
    
    parser = argparse.ArgumentParser(description="Sprintè§„åˆ’å·¥å…·")
    parser.add_argument("--capacity", action="store_true", help="è®¡ç®—å›¢é˜Ÿå®¹é‡")
    parser.add_argument("--members", type=int, default=5, help="å›¢é˜Ÿæˆå‘˜æ•°")
    parser.add_argument("--weeks", type=int, default=2, help="Sprintå‘¨æ•°")
    parser.add_argument("--focus", type=float, default=0.7, help="ä¸“æ³¨ç³»æ•°")
    
    args = parser.parse_args()
    
    if args.capacity:
        planner = SprintCapacityPlanner(team_members=args.members)
        capacity = planner.calculate_capacity(
            sprint_weeks=args.weeks,
            focus_factor=args.focus
        )
        print("\n=== Sprintå®¹é‡è§„åˆ’ ===")
        for key, value in capacity.items():
            print(f"{key}: {value}")
```

### 3.3 çœ‹æ¿å¯è§†åŒ–å·¥å…·

```python
#!/usr/bin/env python3
"""
çœ‹æ¿æ¿å¯è§†åŒ–å·¥å…·
ç”ŸæˆHTMLæ ¼å¼çš„çœ‹æ¿è§†å›¾
"""

from dataclasses import dataclass
from typing import List, Dict
from datetime import datetime


@dataclass
class KanbanCard:
    """çœ‹æ¿å¡ç‰‡"""
    id: str
    title: str
    assignee: str
    priority: str
    tags: List[str]
    blocked: bool = False
    blocked_reason: str = ""
    created_at: datetime = None
    
    def __post_init__(self):
        if self.created_at is None:
            self.created_at = datetime.now()


class KanbanColumn:
    """çœ‹æ¿åˆ—"""
    
    def __init__(self, name: str, wip_limit: int = None):
        self.name = name
        self.wip_limit = wip_limit
        self.cards: List[KanbanCard] = []
    
    def add_card(self, card: KanbanCard) -> bool:
        """æ·»åŠ å¡ç‰‡ï¼Œæ£€æŸ¥WIPé™åˆ¶"""
        if self.wip_limit and len(self.cards) >= self.wip_limit:
            return False
        self.cards.append(card)
        return True
    
    def remove_card(self, card_id: str) -> KanbanCard:
        """ç§»é™¤å¡ç‰‡"""
        for i, card in enumerate(self.cards):
            if card.id == card_id:
                return self.cards.pop(i)
        return None
    
    def is_over_limit(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦è¶…è¿‡WIPé™åˆ¶"""
        return self.wip_limit is not None and len(self.cards) > self.wip_limit
    
    def get_cycle_time_stats(self) -> Dict:
        """è·å–å‘¨æœŸæ—¶é—´ç»Ÿè®¡"""
        if not self.cards:
            return {}
        
        cycle_times = [
            (datetime.now() - card.created_at).days 
            for card in self.cards
        ]
        
        return {
            "count": len(self.cards),
            "avg_days": sum(cycle_times) / len(cycle_times),
            "max_days": max(cycle_times),
            "min_days": min(cycle_times)
        }


class KanbanBoard:
    """çœ‹æ¿æ¿"""
    
    def __init__(self, name: str):
        self.name = name
        self.columns: List[KanbanColumn] = []
        self.flow_metrics = []
    
    def add_column(self, column: KanbanColumn):
        self.columns.append(column)
    
    def move_card(self, card_id: str, from_column: str, to_column: str) -> bool:
        """ç§»åŠ¨å¡ç‰‡"""
        source = next((c for c in self.columns if c.name == from_column), None)
        target = next((c for c in self.columns if c.name == to_column), None)
        
        if not source or not target:
            return False
        
        card = source.remove_card(card_id)
        if not card:
            return False
        
        if not target.add_card(card):
            source.add_card(card)  # å›æ»š
            return False
        
        # è®°å½•æµæŒ‡æ ‡
        self.flow_metrics.append({
            "card_id": card_id,
            "from": from_column,
            "to": to_column,
            "timestamp": datetime.now()
        })
        
        return True
    
    def generate_html(self) -> str:
        """ç”ŸæˆHTMLçœ‹æ¿"""
        html = f"""<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>{self.name} - Kanban Board</title>
    <style>
        body {{
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f5f5;
            margin: 0;
            padding: 20px;
        }}
        .board {{
            display: flex;
            gap: 20px;
            overflow-x: auto;
        }}
        .column {{
            min-width: 280px;
            background: #ebecf0;
            border-radius: 8px;
            padding: 12px;
        }}
        .column-header {{
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            font-weight: 600;
            color: #172b4d;
        }}
        .wip-limit {{
            background: {'#ff5630' if self.columns[0].is_over_limit() else '#0052cc'};
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 12px;
        }}
        .card {{
            background: white;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            cursor: pointer;
            transition: transform 0.2s;
        }}
        .card:hover {{
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }}
        .card-blocked {{
            border-left: 4px solid #ff5630;
        }}
        .card-priority-high {{
            border-top: 3px solid #ff5630;
        }}
        .card-priority-medium {{
            border-top: 3px solid #ffab00;
        }}
        .card-priority-low {{
            border-top: 3px solid #36b37e;
        }}
        .card-id {{
            font-size: 11px;
            color: #5e6c84;
            margin-bottom: 4px;
        }}
        .card-title {{
            font-size: 14px;
            color: #172b4d;
            margin-bottom: 8px;
            line-height: 1.4;
        }}
        .card-meta {{
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
        }}
        .card-assignee {{
            background: #dfe1e6;
            padding: 2px 8px;
            border-radius: 12px;
        }}
        .card-tags {{
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
            margin-top: 8px;
        }}
        .tag {{
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 4px;
            background: #e3fcef;
            color: #006644;
        }}
        .blocked-badge {{
            background: #ff5630;
            color: white;
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 4px;
            margin-top: 8px;
        }}
    </style>
</head>
<body>
    <h1>{self.name}</h1>
    <div class="board">
"""
        
        for column in self.columns:
            wip_class = "wip-exceeded" if column.is_over_limit() else ""
            html += f"""
        <div class="column {wip_class}">
            <div class="column-header">
                <span>{column.name}</span>
                <span class="wip-limit">{len(column.cards)}/{column.wip_limit if column.wip_limit else 'âˆ'}</span>
            </div>
"""
            for card in column.cards:
                priority_class = f"card-priority-{card.priority.lower()}"
                blocked_class = "card-blocked" if card.blocked else ""
                
                html += f"""
            <div class="card {priority_class} {blocked_class}">
                <div class="card-id">{card.id}</div>
                <div class="card-title">{card.title}</div>
                <div class="card-meta">
                    <span class="card-assignee">{card.assignee}</span>
                </div>
                <div class="card-tags">
                    {''.join(f'<span class="tag">{tag}</span>' for tag in card.tags)}
                </div>
                {f'<div class="blocked-badge">é˜»å¡: {card.blocked_reason}</div>' if card.blocked else ''}
            </div>
"""
            html += "        </div>\n"
        
        html += """
    </div>
</body>
</html>
"""
        return html
    
    def export_html(self, filepath: str):
        """å¯¼å‡ºä¸ºHTMLæ–‡ä»¶"""
        with open(filepath, 'w', encoding='utf-8') as f:
            f.write(self.generate_html())


# ä½¿ç”¨ç¤ºä¾‹
if __name__ == "__main__":
    # åˆ›å»ºçœ‹æ¿
    board = KanbanBoard("äº§å“è¿­ä»£çœ‹æ¿")
    
    # æ·»åŠ åˆ—
    board.add_column(KanbanColumn("å¾…åŠ", wip_limit=10))
    board.add_column(KanbanColumn("åˆ†æä¸­", wip_limit=3))
    board.add_column(KanbanColumn("å¼€å‘ä¸­", wip_limit=5))
    board.add_column(KanbanColumn("æµ‹è¯•ä¸­", wip_limit=3))
    board.add_column(KanbanColumn("å·²å®Œæˆ"))
    
    # æ·»åŠ å¡ç‰‡
    todo_col = board.columns[0]
    todo_col.add_card(KanbanCard(
        id="KAN-001",
        title="å®ç°ç”¨æˆ·ç™»å½•åŠŸèƒ½",
        assignee="å¼ ä¸‰",
        priority="High",
        tags=["å‰ç«¯", "è®¤è¯"]
    ))
    todo_col.add_card(KanbanCard(
        id="KAN-002",
        title="ä¼˜åŒ–æ•°æ®åº“æŸ¥è¯¢æ€§èƒ½",
        assignee="æå››",
        priority="Medium",
        tags=["åç«¯", "æ€§èƒ½"],
        blocked=True,
        blocked_reason="ç­‰å¾…DBAèµ„æº"
    ))
    
    # å¯¼å‡º
    board.export_html("kanban_board.html")
    print("çœ‹æ¿å·²å¯¼å‡ºåˆ° kanban_board.html")
```

### 3.4 æŒç»­æ”¹è¿› - å›é¡¾ä¼šè®®å·¥å…·

```python
#!/usr/bin/env python3
"""
Sprintå›é¡¾ä¼šè®®å·¥å…·
è‡ªåŠ¨åŒ–æ”¶é›†åé¦ˆã€ç”Ÿæˆè¡ŒåŠ¨é¡¹
"""

from dataclasses import dataclass, field
from typing import List, Dict
from datetime import datetime
from enum import Enum
import json
import random


class FeedbackType(Enum):
    WENT_WELL = "åšå¾—å¥½çš„"
    NEEDS_IMPROVEMENT = "éœ€è¦æ”¹è¿›çš„"
    ACTION_ITEM = "è¡ŒåŠ¨é¡¹"


@dataclass
class RetrospectiveFeedback:
    """å›é¡¾åé¦ˆé¡¹"""
    id: str
    content: str
    feedback_type: FeedbackType
    author: str
    votes: int = 0
    voters: List[str] = field(default_factory=list)
    category: str = "general"  # process, communication, tools, etc.
    created_at: datetime = field(default_factory=datetime.now)
    
    def vote(self, voter: str) -> bool:
        """æŠ•ç¥¨"""
        if voter not in self.voters:
            self.voters.append(voter)
            self.votes += 1
            return True
        return False


@dataclass
class ActionItem:
    """è¡ŒåŠ¨é¡¹"""
    id: str
    description: str
    owner: str
    due_date: datetime
    status: str = "open"  # open, in_progress, done
    related_feedback: List[str] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "description": self.description,
            "owner": self.owner,
            "due_date": self.due_date.isoformat(),
            "status": self.status,
            "related_feedback": self.related_feedback
        }


class RetrospectiveMeeting:
    """å›é¡¾ä¼šè®®ç®¡ç†"""
    
    # é¢„è®¾çš„å›é¡¾æ ¼å¼
    FORMATS = {
        "standard": ["åšå¾—å¥½çš„", "éœ€è¦æ”¹è¿›çš„", "è¡ŒåŠ¨é¡¹"],
        "4ls": ["å–œæ¬¢çš„", "å­¦åˆ°çš„", "ç¼ºä¹çš„", "æ¸´æœ›çš„"],
        "sailboat": ["é£ï¼ˆåŠ©åŠ›ï¼‰", "é”šï¼ˆé˜»ç¢ï¼‰", "ç¤çŸ³ï¼ˆé£é™©ï¼‰", "ç›®æ ‡ï¼ˆæ„¿æ™¯ï¼‰"],
        "mad_sad_glad": ["æ„¤æ€’çš„", "æ‚²ä¼¤çš„", "é«˜å…´çš„"],
        "starfish": ["ç»§ç»­åšçš„", "å°‘åšäº›çš„", "å¤šåšçš„", "å¼€å§‹åšçš„", "åœæ­¢åšçš„"]
    }
    
    def __init__(self, sprint_name: str, format_type: str = "standard"):
        self.sprint_name = sprint_name
        self.format_type = format_type
        self.feedback_items: List[RetrospectiveFeedback] = []
        self.action_items: List[ActionItem] = []
        self.participants: List[str] = []
        self.meeting_date = datetime.now()
        
    def add_feedback(self, content: str, feedback_type: FeedbackType,
                    author: str, category: str = "general") -> RetrospectiveFeedback:
        """æ·»åŠ åé¦ˆ"""
        feedback = RetrospectiveFeedback(
            id=f"FDB-{len(self.feedback_items)+1:03d}",
            content=content,
            feedback_type=feedback_type,
            author=author,
            category=category
        )
        self.feedback_items.append(feedback)
        if author not in self.participants:
            self.participants.append(author)
        return feedback
    
    def generate_action_items(self, min_votes: int = 2) -> List[ActionItem]:
        """åŸºäºé«˜ç¥¨åé¦ˆç”Ÿæˆè¡ŒåŠ¨é¡¹"""
        high_vote_items = [
            f for f in self.feedback_items 
            if f.feedback_type == FeedbackType.NEEDS_IMPROVEMENT 
            and f.votes >= min_votes
        ]
        
        # æŒ‰æŠ•ç¥¨æ•°æ’åºï¼Œå–å‰3ä¸ª
        top_items = sorted(high_vote_items, key=lambda x: x.votes, reverse=True)[:3]
        
        for item in top_items:
            action = ActionItem(
                id=f"ACT-{len(self.action_items)+1:03d}",
                description=f"æ”¹è¿›: {item.content}",
                owner="å¾…åˆ†é…",
                due_date=self.meeting_date + timedelta(weeks=2),
                related_feedback=[item.id]
            )
            self.action_items.append(action)
        
        return self.action_items
    
    def get_sentiment_analysis(self) -> Dict:
        """ç®€å•çš„æƒ…æ„Ÿåˆ†æ"""
        total = len(self.feedback_items)
        if total == 0:
            return {}
        
        positive = len([f for f in self.feedback_items 
                       if f.feedback_type == FeedbackType.WENT_WELL])
        negative = len([f for f in self.feedback_items 
                       if f.feedback_type == FeedbackType.NEEDS_IMPROVEMENT])
        
        return {
            "total_feedback": total,
            "positive_ratio": round(positive / total * 100, 2),
            "negative_ratio": round(negative / total * 100, 2),
            "sentiment_score": round((positive - negative) / total, 2),
            "trend": "positive" if positive > negative else "negative" if negative > positive else "neutral"
        }
    
    def generate_report(self) -> str:
        """ç”Ÿæˆå›é¡¾ä¼šè®®æŠ¥å‘Š"""
        report = f"""
# Sprintå›é¡¾æŠ¥å‘Š

## åŸºæœ¬ä¿¡æ¯
- Sprint: {self.sprint_name}
- æ—¥æœŸ: {self.meeting_date.strftime("%Y-%m-%d")}
- å‚ä¸äººæ•°: {len(self.participants)}
- å›é¡¾æ ¼å¼: {self.format_type}

## æƒ…æ„Ÿåˆ†æ
{json.dumps(self.get_sentiment_analysis(), indent=2, ensure_ascii=False)}

## åé¦ˆæ±‡æ€»

### åšå¾—å¥½çš„ ({len([f for f in self.feedback_items if f.feedback_type == FeedbackType.WENT_WELL])})
"""
        for item in self.feedback_items:
            if item.feedback_type == FeedbackType.WENT_WELL:
                report += f"- {item.content} (ğŸ‘ {item.votes})\n"
        
        report += "\n### éœ€è¦æ”¹è¿›çš„\n"
        for item in self.feedback_items:
            if item.feedback_type == FeedbackType.NEEDS_IMPROVEMENT:
                report += f"- {item.content} (ğŸ‘ {item.votes})\n"
        
        report += "\n## è¡ŒåŠ¨é¡¹\n"
        for item in self.action_items:
            report += f"- [ ] {item.description}\n"
            report += f"  - è´Ÿè´£äºº: {item.owner}\n"
            report += f"  - æˆªæ­¢æ—¥æœŸ: {item.due_date.strftime('%Y-%m-%d')}\n"
        
        return report
    
    def export_report(self, filepath: str):
        """å¯¼å‡ºæŠ¥å‘Š"""
        with open(filepath, 'w', encoding='utf-8') as f:
            f.write(self.generate_report())


# ä½¿ç”¨ç¤ºä¾‹
if __name__ == "__main__":
    # åˆ›å»ºå›é¡¾ä¼šè®®
    retro = RetrospectiveMeeting("Sprint 42", format_type="standard")
    
    # æ”¶é›†åé¦ˆ
    retro.add_feedback(
        "æ¯æ—¥ç«™ä¼šæ•ˆç‡æé«˜ï¼Œå¤§å®¶éƒ½å‡†æ—¶å‚åŠ ",
        FeedbackType.WENT_WELL,
        "å¼ ä¸‰",
        "communication"
    )
    retro.add_feedback(
        "ä»£ç å®¡æŸ¥æ—¶é—´è¿‡é•¿ï¼Œå½±å“å¼€å‘æ•ˆç‡",
        FeedbackType.NEEDS_IMPROVEMENT,
        "æå››",
        "process"
    )
    retro.add_feedback(
        "CI/CDæµæ°´çº¿ç¨³å®šæ€§æå‡",
        FeedbackType.WENT_WELL,
        "ç‹äº”",
        "tools"
    )
    
    # æ¨¡æ‹ŸæŠ•ç¥¨
    for item in retro.feedback_items:
        item.vote("æˆå‘˜A")
        item.vote("æˆå‘˜B")
        if item.content.startswith("ä»£ç å®¡æŸ¥"):
            item.vote("æˆå‘˜C")
    
    # ç”Ÿæˆè¡ŒåŠ¨é¡¹
    retro.generate_action_items(min_votes=2)
    
    # å¯¼å‡ºæŠ¥å‘Š
    retro.export_report("sprint_retrospective.md")
    print(retro.generate_report())
```

### 3.5 æ•æ·æŒ‡æ ‡ä»ªè¡¨æ¿

```python
#!/usr/bin/env python3
"""
æ•æ·æŒ‡æ ‡ä»ªè¡¨æ¿ç”Ÿæˆå™¨
ç”ŸæˆåŒ…å«å…³é”®æ•æ·æŒ‡æ ‡çš„å¯è§†åŒ–æŠ¥å‘Š
"""

import matplotlib.pyplot as plt
import matplotlib.dates as mdates
from datetime import datetime, timedelta
from typing import List, Dict
import json


class AgileMetricsDashboard:
    """æ•æ·æŒ‡æ ‡ä»ªè¡¨æ¿"""
    
    def __init__(self, team_name: str):
        self.team_name = team_name
        self.sprint_data = []
        self.velocity_history = []
        self.cycle_times = []
        
    def add_sprint_data(self, sprint_data: Dict):
        """æ·»åŠ Sprintæ•°æ®"""
        self.sprint_data.append(sprint_data)
    
    def calculate_lead_time(self, created_date: datetime, 
                          completed_date: datetime) -> int:
        """è®¡ç®—å‰ç½®æ—¶é—´ï¼ˆå¤©ï¼‰"""
        return (completed_date - created_date).days
    
    def calculate_cycle_time(self, started_date: datetime,
                           completed_date: datetime) -> int:
        """è®¡ç®—å‘¨æœŸæ—¶é—´ï¼ˆå¤©ï¼‰"""
        return (completed_date - started_date).days
    
    def calculate_velocity(self, completed_story_points: List[int]) -> Dict:
        """è®¡ç®—é€Ÿåº¦æŒ‡æ ‡"""
        if not completed_story_points:
            return {}
        
        n = len(completed_story_points)
        avg = sum(completed_story_points) / n
        
        # è®¡ç®—æ ‡å‡†å·®
        variance = sum((x - avg) ** 2 for x in completed_story_points) / n
        std_dev = variance ** 0.5
        
        return {
            "average_velocity": round(avg, 2),
            "min_velocity": min(completed_story_points),
            "max_velocity": max(completed_story_points),
            "std_deviation": round(std_dev, 2),
            "predictability": round((1 - std_dev/avg) * 100, 2) if avg else 0
        }
    
    def calculate_flow_efficiency(self, active_time: float, 
                                 wait_time: float) -> float:
        """
        è®¡ç®—æµåŠ¨æ•ˆç‡
        æµåŠ¨æ•ˆç‡ = æ´»è·ƒæ—¶é—´ / (æ´»è·ƒæ—¶é—´ + ç­‰å¾…æ—¶é—´)
        """
        total_time = active_time + wait_time
        return round(active_time / total_time * 100, 2) if total_time else 0
    
    def generate_velocity_chart(self, output_path: str = "velocity_chart.png"):
        """ç”Ÿæˆé€Ÿåº¦å›¾"""
        sprints = [f"Sprint {i+1}" for i in range(len(self.velocity_history))]
        velocities = self.velocity_history
        
        if len(velocities) < 2:
            print("éœ€è¦è‡³å°‘2ä¸ªSprintçš„é€Ÿåº¦æ•°æ®")
            return
        
        fig, ax = plt.subplots(figsize=(12, 6))
        
        # æŸ±çŠ¶å›¾
        bars = ax.bar(sprints, velocities, color='#0052cc', alpha=0.7)
        
        # å¹³å‡çº¿
        avg_velocity = sum(velocities) / len(velocities)
        ax.axhline(y=avg_velocity, color='#ff5630', linestyle='--', 
                  label=f'å¹³å‡é€Ÿåº¦: {avg_velocity:.1f}')
        
        # é¢„æµ‹åŒºé—´ï¼ˆÂ±1æ ‡å‡†å·®ï¼‰
        variance = sum((v - avg_velocity) ** 2 for v in velocities) / len(velocities)
        std_dev = variance ** 0.5
        ax.fill_between(range(len(sprints)), 
                       [avg_velocity - std_dev] * len(sprints),
                       [avg_velocity + std_dev] * len(sprints),
                       alpha=0.2, color='#ff5630', label=f'é¢„æµ‹åŒºé—´ (Â±{std_dev:.1f})')
        
        ax.set_xlabel('Sprint')
        ax.set_ylabel('æ•…äº‹ç‚¹')
        ax.set_title(f'{self.team_name} - å›¢é˜Ÿé€Ÿåº¦è¶‹åŠ¿')
        ax.legend()
        ax.grid(True, alpha=0.3)
        
        plt.xticks(rotation=45)
        plt.tight_layout()
        plt.savefig(output_path, dpi=150)
        print(f"é€Ÿåº¦å›¾å·²ä¿å­˜åˆ°: {output_path}")
    
    def generate_cfd(self, flow_data: Dict, output_path: str = "cfd.png"):
        """
        ç”Ÿæˆç´¯ç§¯æµå›¾ (Cumulative Flow Diagram)
        
        flow_dataæ ¼å¼: {
            "dates": [date1, date2, ...],
            "columns": {
                "å¾…åŠ": [count1, count2, ...],
                "è¿›è¡Œä¸­": [count1, count2, ...],
                ...
            }
        }
        """
        fig, ax = plt.subplots(figsize=(14, 7))
        
        dates = flow_data["dates"]
        colors = ['#0052cc', '#00b8d9', '#36b37e', '#ffab00', '#ff5630']
        
        # è®¡ç®—ç´¯ç§¯å€¼
        bottom = [0] * len(dates)
        for i, (column, values) in enumerate(flow_data["columns"].items()):
            ax.fill_between(dates, bottom, 
                          [b + v for b, v in zip(bottom, values)],
                          label=column, color=colors[i % len(colors)], alpha=0.8)
            bottom = [b + v for b, v in zip(bottom, values)]
        
        ax.set_xlabel('æ—¥æœŸ')
        ax.set_ylabel('å·¥ä½œé¡¹æ•°é‡')
        ax.set_title(f'{self.team_name} - ç´¯ç§¯æµå›¾')
        ax.legend(loc='upper left')
        ax.grid(True, alpha=0.3)
        
        # æ—¥æœŸæ ¼å¼åŒ–
        ax.xaxis.set_major_formatter(mdates.DateFormatter('%m-%d'))
        plt.xticks(rotation=45)
        plt.tight_layout()
        plt.savefig(output_path, dpi=150)
        print(f"ç´¯ç§¯æµå›¾å·²ä¿å­˜åˆ°: {output_path}")
    
    def generate_metrics_summary(self) -> str:
        """ç”ŸæˆæŒ‡æ ‡æ‘˜è¦æŠ¥å‘Š"""
        velocity_metrics = self.calculate_velocity(self.velocity_history)
        
        summary = f"""
# {self.team_name} - æ•æ·æŒ‡æ ‡æ‘˜è¦

## é€Ÿåº¦æŒ‡æ ‡
- å¹³å‡é€Ÿåº¦: {velocity_metrics.get('average_velocity', 'N/A')} æ•…äº‹ç‚¹/Sprint
- é€Ÿåº¦èŒƒå›´: {velocity_metrics.get('min_velocity', 'N/A')} - {velocity_metrics.get('max_velocity', 'N/A')}
- å¯é¢„æµ‹æ€§: {velocity_metrics.get('predictability', 'N/A')}%

## æµåŠ¨æ•ˆç‡
å¥åº·çš„æµåŠ¨æ•ˆç‡åº”åœ¨15-40%ä¹‹é—´ã€‚
ä½äº15%è¡¨ç¤ºç­‰å¾…æ—¶é—´è¿‡é•¿ï¼Œéœ€è¦ä¼˜åŒ–æµç¨‹ã€‚

## å»ºè®®
1. ä¿æŒSprinté•¿åº¦ä¸€è‡´ï¼Œæé«˜å¯é¢„æµ‹æ€§
2. é™åˆ¶åœ¨åˆ¶å“æ•°é‡ï¼Œå‡å°‘ä¸Šä¸‹æ–‡åˆ‡æ¢
3. å®šæœŸè¿›è¡Œå›é¡¾ï¼ŒæŒç»­æ”¹è¿›æµç¨‹
"""
        return summary


# ä½¿ç”¨ç¤ºä¾‹
if __name__ == "__main__":
    dashboard = AgileMetricsDashboard("å‰ç«¯å¼€å‘å›¢é˜Ÿ")
    
    # æ·»åŠ é€Ÿåº¦å†å²
    dashboard.velocity_history = [23, 28, 25, 30, 27, 29, 31, 26]
    
    # ç”Ÿæˆå›¾è¡¨
    dashboard.generate_velocity_chart()
    
    # ç”Ÿæˆç´¯ç§¯æµå›¾æ•°æ®
    from datetime import datetime, timedelta
    dates = [datetime.now() - timedelta(days=i) for i in range(14, 0, -1)]
    cfd_data = {
        "dates": dates,
        "columns": {
            "å¾…åŠ": [15, 14, 16, 15, 13, 12, 14, 13, 15, 14, 16, 15, 14, 13],
            "åˆ†æä¸­": [3, 4, 3, 4, 5, 4, 3, 4, 3, 4, 3, 3, 4, 3],
            "å¼€å‘ä¸­": [5, 5, 6, 5, 5, 6, 5, 5, 6, 5, 5, 6, 5, 5],
            "æµ‹è¯•ä¸­": [2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 2, 3, 2],
            "å·²å®Œæˆ": [8, 10, 12, 15, 18, 21, 24, 27, 30, 33, 36, 39, 42, 45]
        }
    }
    dashboard.generate_cfd(cfd_data)
    
    # æ‰“å°æŠ¥å‘Š
    print(dashboard.generate_metrics_summary())
```

## 4. èµ„æºç´¢å¼•

### 4.1 å®˜æ–¹æ–‡æ¡£

| èµ„æºåç§° | é“¾æ¥ | è¯´æ˜ |
|---------|------|------|
| ScrumæŒ‡å— | https://scrumguides.org | Scrumå®˜æ–¹æŒ‡å—ï¼ŒKen Schwaber & Jeff Sutherland |
| KanbanæŒ‡å— | https://kanbanguides.org | Kanbanå®˜æ–¹æŒ‡å— |
| æ•æ·å®£è¨€ | https://agilemanifesto.org | æ•æ·è½¯ä»¶å¼€å‘å®£è¨€åŸæ–‡ |
| LeSSæ¡†æ¶ | https://less.works | å¤§è§„æ¨¡Scrumå®˜æ–¹ç«™ç‚¹ |
| SAFeæ¡†æ¶ | https://scaledagileframework.com | è§„æ¨¡åŒ–æ•æ·æ¡†æ¶ |

### 4.2 æ¨èå·¥å…·

| ç±»åˆ« | å·¥å…· | å®˜ç½‘ | ç‰¹ç‚¹ |
|-----|-----|------|-----|
| é¡¹ç›®ç®¡ç† | Jira | https://www.atlassian.com/software/jira | ä¼ä¸šçº§æ•æ·ç®¡ç† |
| é¡¹ç›®ç®¡ç† | Azure DevOps | https://azure.microsoft.com/devops | å¾®è½¯å…¨é“¾è·¯æ–¹æ¡ˆ |
| çœ‹æ¿å·¥å…· | Trello | https://trello.com | ç®€æ´æ˜“ç”¨çš„çœ‹æ¿ |
| çœ‹æ¿å·¥å…· | Kanbanize | https://kanbanize.com | é«˜çº§çœ‹æ¿åˆ†æåŠŸèƒ½ |
| åä½œç™½æ¿ | Miro | https://miro.com | è¿œç¨‹å›é¡¾ä¼šè®®é¦–é€‰ |
| åä½œç™½æ¿ | Mural | https://mural.co | å¯è§†åŒ–åä½œå¹³å° |
| æ•æ·ä¼°ç®— | PlanningPoker | https://www.planningpoker.com | åœ¨çº¿è§„åˆ’æ‰‘å…‹ |
| æŒ‡æ ‡åˆ†æ | ActionableAgile | https://actionableagile.com | æµæ•°æ®åˆ†æä¸“ä¸šå·¥å…· |

### 4.3 ä¹¦ç±æ¨è

1. **ã€ŠScrumæŒ‡å—ã€‹** - Ken Schwaber, Jeff Sutherland
2. **ã€Šçœ‹æ¿æ–¹æ³•ã€‹** - David J. Anderson
3. **ã€Šç”¨æˆ·æ•…äº‹ä¸æ•æ·æ–¹æ³•ã€‹** - Mike Cohn
4. **ã€Šæ•æ·ä¼°è®¡ä¸è§„åˆ’ã€‹** - Mike Cohn
5. **ã€ŠSucceeding with Agileã€‹** - Mike Cohn
6. **ã€ŠEssential Kanban Condensedã€‹** - David J. Anderson
7. **ã€ŠTeam Topologiesã€‹** - Matthew Skelton, Manuel Pais

### 4.4 è®¤è¯è·¯å¾„

| è®¤è¯ | é¢å‘æœºæ„ | çº§åˆ« |
|-----|---------|-----|
| PSM (Professional Scrum Master) | Scrum.org | åŸºç¡€/ä¸­çº§/é«˜çº§ |
| CSM (Certified ScrumMaster) | Scrum Alliance | åŸºç¡€ |
| CSPO (Certified Scrum Product Owner) | Scrum Alliance | åŸºç¡€ |
| ICP (ICAgile Certified Professional) | ICAgile | å¤šä¸ªä¸“ä¸šæ–¹å‘ |
| SAFe Agilist (SA) | Scaled Agile | è§„æ¨¡åŒ–æ•æ· |
| KMP (Kanban Management Professional) | Kanban University | Kanbanä¸“ä¸š |

## 5. å…³è”çŸ¥è¯†

### 5.1 ä¸Šæ¸¸å…³è”

```
A02_Engineering_Processes
â”œâ”€â”€ B01_SDLC_Frameworks
â”‚   â”œâ”€â”€ C01_Agile_Methodologies (æœ¬å•å…ƒ)
â”‚   â”œâ”€â”€ C02_DevOps_Integration â”€â”€â–º éœ€è¦æ•æ·çš„è¿­ä»£èŠ‚å¥æ”¯æ’‘
â”‚   â””â”€â”€ C03_Quality_Gates â”€â”€â”€â”€â”€â”€â”€â–º æ•æ·ä¸­çš„è´¨é‡å†…å»ºå®è·µ
```

### 5.2 ä¸‹æ¸¸å…³è”

```
C01_Agile_Methodologies
â”œâ”€â”€ A03_Core_Technologies
â”‚   â”œâ”€â”€ B01_Programming_Languages â”€â”€â–º æŠ€æœ¯å€ºåŠ¡ç®¡ç†
â”‚   â”œâ”€â”€ B02_Software_Architecture â”€â”€â–º æ¼”è¿›å¼æ¶æ„
â”‚   â””â”€â”€ B03_Infrastructure â”€â”€â”€â”€â”€â”€â”€â”€â–º æŒç»­äº¤ä»˜æ”¯æ’‘
â”œâ”€â”€ A05_Operations_Excellence
â”‚   â”œâ”€â”€ B01_Monitoring_Observability â–º æ•æ·åé¦ˆå¾ªç¯
â”‚   â””â”€â”€ B02_Incident_Management â”€â”€â”€â”€â–º å¿«é€Ÿå“åº”æœºåˆ¶
â””â”€â”€ A06_Leadership_Management
    â”œâ”€â”€ B01_Technical_Leadership â”€â”€â”€â–º æœåŠ¡å‹é¢†å¯¼
    â””â”€â”€ B03_Team_Dynamics â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º é«˜ç»©æ•ˆå›¢é˜Ÿ
```

### 5.3 æ¨ªå‘å…³è”

- **ä¸DevOpsçš„èåˆ**ï¼šæ•æ·æä¾›è¿­ä»£èŠ‚å¥ï¼ŒDevOpsæä¾›æŠ€æœ¯å®è·µï¼Œå…±åŒæ„æˆç°ä»£è½¯ä»¶äº¤ä»˜åŸºç¡€
- **ä¸ç²¾ç›Šæ€æƒ³çš„ç»“åˆ**ï¼šæ¶ˆé™¤æµªè´¹ã€æŒç»­æ”¹è¿›æ˜¯ä¸¤è€…çš„å…±åŒç›®æ ‡
- **ä¸ç³»ç»Ÿæ€ç»´çš„æ•´åˆ**ï¼šä»å±€éƒ¨ä¼˜åŒ–è½¬å‘ä»·å€¼æµä¼˜åŒ–

## 6. å­¦ä¹ å»ºè®®

### 6.1 æ–°æ‰‹å…¥é—¨è·¯å¾„ï¼ˆ1-3ä¸ªæœˆï¼‰

```
ç¬¬1å‘¨ï¼šç†è®ºåŸºç¡€
â”œâ”€â”€ é˜…è¯»ã€ŠScrumæŒ‡å—ã€‹ï¼ˆä¸­æ–‡ç‰ˆçº¦16é¡µï¼‰
â”œâ”€â”€ è§‚çœ‹Scrum.orgå®˜æ–¹è§†é¢‘
â””â”€â”€ å®ŒæˆScrum Openè¯„ä¼°

ç¬¬2-3å‘¨ï¼šå®è·µè§‚æ‘©
â”œâ”€â”€ å‚åŠ çœŸå®Sprintä¼šè®®ï¼ˆä½œä¸ºè§‚å¯Ÿè€…ï¼‰
â”œâ”€â”€ è®°å½•ä¼šè®®ä¸­çš„é—®é¢˜å’Œäº®ç‚¹
â””â”€â”€ ä¸Scrum Masteräº¤æµ

ç¬¬4å‘¨ï¼šå·¥å…·ä¸Šæ‰‹
â”œâ”€â”€ åˆ›å»ºJira/Confluenceè´¦æˆ·
â”œâ”€â”€ å®Œæˆä¸€ä¸ªç®€å•é¡¹ç›®çš„è®¾ç½®
â””â”€â”€ ç»ƒä¹ çœ‹æ¿é…ç½®

ç¬¬2-3æœˆï¼šæ·±åº¦å‚ä¸
â”œâ”€â”€ æ‹…ä»»Scrumå›¢é˜Ÿä¸€å‘˜
â”œâ”€â”€ å‚ä¸ç”¨æˆ·æ•…äº‹ç¼–å†™
â””â”€â”€ ä¸»æŒè‡³å°‘ä¸€æ¬¡å›é¡¾ä¼šè®®
```

### 6.2 è¿›é˜¶æå‡è·¯å¾„ï¼ˆ3-12ä¸ªæœˆï¼‰

1. **è·å¾—ä¸“ä¸šè®¤è¯**ï¼šPSM Iã€CSM æˆ– ICP
2. **æ‰©å±•æ¡†æ¶çŸ¥è¯†**ï¼šå­¦ä¹ Kanbanã€XPã€SAFe
3. **æŒæ¡åº¦é‡æŠ€èƒ½**ï¼šå­¦ä¹ æµæ•°æ®åˆ†æã€é¢„æµ‹æŠ€æœ¯
4. **æ•™ç»ƒæŠ€èƒ½åŸ¹å…»**ï¼šå­¦ä¹ å¼•å¯¼æŠ€æœ¯ã€å†²çªè§£å†³
5. **è§„æ¨¡åŒ–ç»éªŒ**ï¼šå‚ä¸å¤šå›¢é˜Ÿåä½œçš„å¤§å‹æ•æ·é¡¹ç›®

### 6.3 ä¸“å®¶å‘å±•è·¯å¾„ï¼ˆ1å¹´+ï¼‰

1. **è·å¾—é«˜çº§è®¤è¯**ï¼šPSM IIIã€SPCã€KMP
2. **æˆä¸ºå˜é©æ¨åŠ¨è€…**ï¼šä¸»å¯¼ç»„ç»‡çº§æ•æ·è½¬å‹
3. **è´¡çŒ®ç¤¾åŒº**ï¼šæ’°å†™åšå®¢ã€æ¼”è®²åˆ†äº«ã€å¼€æºå·¥å…·
4. **è·¨é¢†åŸŸèåˆ**ï¼šå°†æ•æ·æ€æƒ³åº”ç”¨åˆ°éITé¢†åŸŸ
5. **ç ”ç©¶ä¸åˆ›æ–°**ï¼šæ¢ç´¢æ•æ·çš„æ–°è¾¹ç•Œï¼ˆAIè¾…åŠ©ã€è¿œç¨‹åä½œç­‰ï¼‰

### 6.4 å­¦ä¹ æ£€æŸ¥æ¸…å•

- [ ] èƒ½å¤Ÿæ¸…æ™°è§£é‡Šæ•æ·å®£è¨€çš„4ä¸ªä»·å€¼è§‚
- [ ] èƒ½å¤Ÿä¸»æŒå®Œæ•´çš„Sprintå‘¨æœŸæ‰€æœ‰ä»ªå¼
- [ ] èƒ½å¤Ÿä½¿ç”¨è‡³å°‘ä¸¤ç§ç”¨æˆ·æ•…äº‹ä¼°ç®—æ–¹æ³•
- [ ] èƒ½å¤Ÿåˆ†æå’Œæ”¹è¿›å›¢é˜Ÿçš„æµåŠ¨æ•ˆç‡
- [ ] èƒ½å¤Ÿè®¾è®¡å’Œä¸»æŒæœ‰æ•ˆçš„å›é¡¾ä¼šè®®
- [ ] èƒ½å¤ŸæŒ‡å¯¼å›¢é˜Ÿå®æ–½æŒç»­æ”¹è¿›
- [ ] èƒ½å¤Ÿå¤„ç†æ•æ·å®æ–½ä¸­çš„å¸¸è§é˜»åŠ›
- [ ] èƒ½å¤Ÿå°†æ•æ·åŸåˆ™åº”ç”¨åˆ°æ–°é¢†åŸŸ

---

*æœ€åæ›´æ–°ï¼š2024å¹´ | ç»´æŠ¤è€…ï¼šå·¥ç¨‹æµç¨‹å§”å‘˜ä¼š*
